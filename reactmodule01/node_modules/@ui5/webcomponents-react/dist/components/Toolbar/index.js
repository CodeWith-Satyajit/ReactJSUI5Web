var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { debounce, enrichEventWithDetails, useI18nBundle, useIsomorphicLayoutEffect, useSyncRef } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { createRef, forwardRef, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { ToolbarDesign, ToolbarStyle } from '../../enums';
import { SHOW_MORE } from '../../i18n/i18n-defaults';
import { flattenFragments } from '../../internal/utils';
import { OverflowPopover } from './OverflowPopover';
import { styles } from './Toolbar.jss';
const useStyles = createUseStyles(styles, { name: 'Toolbar' });
const OVERFLOW_BUTTON_WIDTH = 36 + 8 + 8; // width + padding end + spacing start
/**
 * Horizontal container most commonly used to display buttons, labels, selects and various other input controls.
 *
 * The content of the `Toolbar` moves into the overflow area from right to left when the available space is not enough in the visible area of the container.
 * It can be accessed by the user through the overflow button that opens it in a popover.
 */
const Toolbar = forwardRef((props, ref) => {
    const { children, toolbarStyle, design, active, style, className, onClick, slot, as, portalContainer, numberOfAlwaysVisibleItems, onOverflowChange, overflowPopoverRef, overflowButton } = props, rest = __rest(props, ["children", "toolbarStyle", "design", "active", "style", "className", "onClick", "slot", "as", "portalContainer", "numberOfAlwaysVisibleItems", "onOverflowChange", "overflowPopoverRef", "overflowButton"]);
    const classes = useStyles();
    const [componentRef, outerContainer] = useSyncRef(ref);
    const controlMetaData = useRef([]);
    const [lastVisibleIndex, setLastVisibleIndex] = useState(null);
    const contentRef = useRef(null);
    const overflowContentRef = useRef(null);
    const overflowBtnRef = useRef(null);
    const [minWidth, setMinWidth] = useState('0');
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    const showMoreText = i18nBundle.getText(SHOW_MORE);
    const toolbarClasses = clsx(classes.outerContainer, toolbarStyle === ToolbarStyle.Clear && classes.clear, active && classes.active, design === ToolbarDesign.Solid && classes.solid, design === ToolbarDesign.Transparent && classes.transparent, design === ToolbarDesign.Info && classes.info, className);
    const flatChildren = useMemo(() => {
        return flattenFragments(children, 10);
    }, [children]);
    const childrenWithRef = useMemo(() => {
        controlMetaData.current = [];
        return flatChildren.map((item, index) => {
            var _a;
            const itemRef = createRef();
            const isSpacer = ((_a = item === null || item === void 0 ? void 0 : item.type) === null || _a === void 0 ? void 0 : _a.displayName) === 'ToolbarSpacer';
            controlMetaData.current.push({
                ref: itemRef,
                isSpacer
            });
            if (isSpacer) {
                return item;
            }
            return (React.createElement("div", { ref: itemRef, key: index, className: classes.childContainer, "data-component-name": "ToolbarChildContainer" }, item));
        });
    }, [flatChildren, controlMetaData, classes.childContainer]);
    const overflowNeeded = (lastVisibleIndex || lastVisibleIndex === 0) &&
        React.Children.count(childrenWithRef) !== lastVisibleIndex + 1 &&
        numberOfAlwaysVisibleItems < React.Children.count(flatChildren);
    useEffect(() => {
        let lastElementResizeObserver;
        const lastElement = contentRef.current.children[numberOfAlwaysVisibleItems - 1];
        const debouncedObserverFn = debounce(() => {
            setMinWidth(`${lastElement.getBoundingClientRect().right + OVERFLOW_BUTTON_WIDTH}px`);
        }, 200);
        if (numberOfAlwaysVisibleItems && overflowNeeded && lastElement) {
            lastElementResizeObserver = new ResizeObserver(debouncedObserverFn);
            lastElementResizeObserver.observe(contentRef.current);
        }
        return () => {
            debouncedObserverFn.cancel();
            lastElementResizeObserver === null || lastElementResizeObserver === void 0 ? void 0 : lastElementResizeObserver.disconnect();
        };
    }, [numberOfAlwaysVisibleItems, overflowNeeded]);
    const requestAnimationFrameRef = useRef();
    const calculateVisibleItems = useCallback(() => {
        requestAnimationFrameRef.current = requestAnimationFrame(() => {
            if (!outerContainer.current)
                return;
            const availableWidth = outerContainer.current.getBoundingClientRect().width;
            let consumedWidth = 0;
            let lastIndex = null;
            if (availableWidth - OVERFLOW_BUTTON_WIDTH <= 0) {
                lastIndex = -1;
            }
            else {
                let prevItemsAreSpacer = true;
                controlMetaData.current.forEach((item, index) => {
                    const currentMeta = controlMetaData.current[index];
                    if (currentMeta && currentMeta.ref && currentMeta.ref.current) {
                        let nextWidth = currentMeta.ref.current.getBoundingClientRect().width;
                        nextWidth += index === 0 || index === controlMetaData.current.length - 1 ? 4 : 8; // first & last element = padding: 4px
                        if (index === controlMetaData.current.length - 1) {
                            if (consumedWidth + nextWidth <= availableWidth - 8) {
                                lastIndex = index;
                            }
                            else if (index === 0 || prevItemsAreSpacer) {
                                lastIndex = index - 1;
                            }
                        }
                        else {
                            if (consumedWidth + nextWidth <= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                                lastIndex = index;
                            }
                            if (consumedWidth < availableWidth - OVERFLOW_BUTTON_WIDTH &&
                                consumedWidth + nextWidth >= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                                lastIndex = index - 1;
                            }
                        }
                        if (prevItemsAreSpacer && !item.isSpacer) {
                            prevItemsAreSpacer = false;
                        }
                        consumedWidth += nextWidth;
                    }
                });
            }
            setLastVisibleIndex(lastIndex);
        });
    }, [outerContainer.current, controlMetaData.current, setLastVisibleIndex, childrenWithRef, overflowNeeded]);
    const observer = useRef(new ResizeObserver(calculateVisibleItems));
    useEffect(() => {
        if (outerContainer.current) {
            observer.current.observe(outerContainer.current);
        }
        return () => {
            cancelAnimationFrame(requestAnimationFrameRef.current);
            observer.current.disconnect();
        };
    }, [outerContainer.current]);
    useIsomorphicLayoutEffect(() => {
        calculateVisibleItems();
    }, [calculateVisibleItems]);
    const handleToolbarClick = useCallback((e) => {
        if (active && typeof onClick === 'function') {
            onClick(enrichEventWithDetails(e));
        }
    }, [onClick, active]);
    const prevChildren = useRef(flatChildren);
    const debouncedOverflowChange = useRef(debounce(onOverflowChange, 60));
    useEffect(() => {
        debouncedOverflowChange.current = debounce(onOverflowChange, 60);
    }, [onOverflowChange]);
    useEffect(() => {
        var _a, _b;
        const haveChildrenChanged = prevChildren.current.length !== flatChildren.length;
        if ((lastVisibleIndex !== null || haveChildrenChanged) && typeof onOverflowChange === 'function') {
            prevChildren.current = flatChildren;
            const toolbarChildren = (_a = contentRef.current) === null || _a === void 0 ? void 0 : _a.children;
            let toolbarElements = [];
            const overflowElements = (_b = overflowContentRef.current) === null || _b === void 0 ? void 0 : _b.children;
            if ((toolbarChildren === null || toolbarChildren === void 0 ? void 0 : toolbarChildren.length) > 0) {
                toolbarElements = Array.from(toolbarChildren).filter((item, index) => index <= lastVisibleIndex);
            }
            debouncedOverflowChange.current({
                toolbarElements,
                overflowElements,
                target: outerContainer.current
            });
        }
        return () => {
            debouncedOverflowChange.current.cancel();
        };
    }, [lastVisibleIndex, flatChildren, debouncedOverflowChange]);
    const CustomTag = as;
    const styleWithMinWidth = minWidth !== '0' ? Object.assign({ minWidth }, style) : style;
    return (React.createElement(CustomTag, Object.assign({ style: styleWithMinWidth, className: clsx(toolbarClasses, overflowNeeded && classes.hasOverflow), ref: componentRef, slot: slot, onClick: handleToolbarClick }, rest),
        React.createElement("div", { className: classes.toolbar, "data-component-name": "ToolbarContent", ref: contentRef },
            overflowNeeded &&
                React.Children.map(childrenWithRef, (item, index) => {
                    if (index >= lastVisibleIndex + 1 && index > numberOfAlwaysVisibleItems - 1) {
                        return React.cloneElement(item, {
                            style: { visibility: 'hidden', position: 'absolute', pointerEvents: 'none' }
                        });
                    }
                    return item;
                }),
            !overflowNeeded && childrenWithRef),
        overflowNeeded && (React.createElement("div", { ref: overflowBtnRef, className: classes.overflowButtonContainer, "data-component-name": "ToolbarOverflowButtonContainer" },
            React.createElement(OverflowPopover, { overflowPopoverRef: overflowPopoverRef, lastVisibleIndex: lastVisibleIndex, classes: classes, portalContainer: portalContainer, overflowContentRef: overflowContentRef, numberOfAlwaysVisibleItems: numberOfAlwaysVisibleItems, showMoreText: showMoreText, overflowButton: overflowButton }, flatChildren)))));
});
Toolbar.defaultProps = {
    as: 'div',
    toolbarStyle: ToolbarStyle.Standard,
    design: ToolbarDesign.Auto,
    active: false,
    portalContainer: document.body,
    numberOfAlwaysVisibleItems: 0
};
Toolbar.displayName = 'Toolbar';
export { Toolbar };
