var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { isPhone } from '@ui5/webcomponents-base/dist/Device.js';
import { useI18nBundle, useSyncRef } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { Children, forwardRef, useReducer, useRef } from 'react';
import { createPortal } from 'react-dom';
import { createUseStyles } from 'react-jss';
import { ButtonDesign } from '../../enums';
import { AVAILABLE_ACTIONS, CANCEL, X_OF_Y } from '../../i18n/i18n-defaults';
import { addCustomCSSWithScoping } from '../../internal/addCustomCSSWithScoping';
import { CustomThemingParameters } from '../../themes/CustomVariables';
import { Button, ResponsivePopover } from '../../webComponents';
import styles from './ActionSheet.jss';
const useStyles = createUseStyles(styles, { name: 'ActionSheet' });
if (isPhone()) {
    addCustomCSSWithScoping('ui5-responsive-popover', `
  :host([data-actionsheet]) [ui5-button] {
    display: none;
  }
  :host([data-actionsheet]) [ui5-dialog] {
    top: auto !important;
    bottom: 0;
    height: auto;
    border-radius: ${CustomThemingParameters.ActionSheetMobileHeaderBorderRadius};
    background-color: ${CustomThemingParameters.ActionSheetMobileHeaderBackground};
    box-shadow: ${CustomThemingParameters.ActionSheetMobileHeaderBoxShadow};
    box-sizing: border-box;
    min-height: unset;
  }
  :host([data-actionsheet]) [ui5-title] {
    color: ${CustomThemingParameters.ActionSheetMobileHeaderTextColor} !important;
    text-shadow: none;
    text-align: start !important;
  }
  `);
}
function ActionSheetButton(props) {
    const { index, totalLength } = props, buttonProps = __rest(props, ["index", "totalLength"]);
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    return (React.createElement(Button
    // aria-describedby={ariaTextId}
    , Object.assign({ 
        // aria-describedby={ariaTextId}
        accessibleName: `${buttonProps.children} ${i18nBundle.getText(X_OF_Y, index + 1, totalLength)}` }, buttonProps, { design: ButtonDesign.Transparent, "data-action-btn-index": index })));
    // const id = useIsomorphicId();
    // const ariaTextId = `__button${id}-actionSheetHiddenText`;
    // <span id={ariaTextId} aria-hidden="true" className={classes.hiddenText}>
    //   {i18nBundle.getText(X_OF_Y, index + 1, totalLength)}
    // </span>
}
/**
 * The `ActionSheet` holds a list of buttons from which the user can select to complete an action.
 *
 * The children of the action sheet should be `Button` components. Elements in the `ActionSheet` are left-aligned. Actions should be arranged in order of importance, from top to bottom.
 *
 * ### Guidelines
 * - Always display text or text and icons for the actions. Do not use icons only.
 * - Always provide a Cancel button on mobile phones.
 * - Avoid scrolling on action sheets.
 *
 */
const ActionSheet = forwardRef((props, ref) => {
    var _a, _b;
    const { a11yConfig, allowTargetOverlap, children, className, footer, header, headerText, hideArrow, horizontalAlign, initialFocus, modal, placementType, portalContainer, showCancelButton, slot, style, verticalAlign, onAfterClose, onAfterOpen, onBeforeClose, onBeforeOpen } = props, rest = __rest(props, ["a11yConfig", "allowTargetOverlap", "children", "className", "footer", "header", "headerText", "hideArrow", "horizontalAlign", "initialFocus", "modal", "placementType", "portalContainer", "showCancelButton", "slot", "style", "verticalAlign", "onAfterClose", "onAfterOpen", "onBeforeClose", "onBeforeOpen"]);
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    const classes = useStyles();
    const [componentRef, popoverRef] = useSyncRef(ref);
    const actionBtnsRef = useRef(null);
    const [focusedItem, setFocusedItem] = useReducer((_, action) => {
        return parseInt(action.target.dataset.actionBtnIndex);
    }, 0);
    const childrenToRender = Children.toArray(children).filter(Boolean);
    const childrenArrayLength = childrenToRender.length;
    const childrenLength = isPhone() && showCancelButton ? childrenArrayLength + 1 : childrenArrayLength;
    const handleCancelBtnClick = () => {
        popoverRef.current.close();
    };
    const renderActionSheetButton = (element, index, childrenArray) => {
        return (React.createElement(ActionSheetButton, Object.assign({ key: index, index: index, totalLength: childrenArray.length, tabIndex: focusedItem === index ? 0 : -1 }, element.props, { onClick: (e) => {
                var _a, _b;
                popoverRef.current.close();
                if (typeof ((_a = element.props) === null || _a === void 0 ? void 0 : _a.onClick) === 'function') {
                    (_b = element.props) === null || _b === void 0 ? void 0 : _b.onClick(e);
                }
            }, onFocus: (e) => {
                var _a, _b;
                if (typeof ((_a = element.props) === null || _a === void 0 ? void 0 : _a.onFocus) === 'function') {
                    (_b = element.props) === null || _b === void 0 ? void 0 : _b.onFocus(e);
                }
                setFocusedItem(e);
            } })));
    };
    const handleAfterOpen = (e) => {
        if (isPhone()) {
            actionBtnsRef.current.querySelector(`[data-action-btn-index="${focusedItem}"]`).focus();
        }
        if (typeof onAfterOpen === 'function') {
            onAfterOpen(e);
        }
    };
    const handleKeyDown = (e) => {
        const currentIndex = parseInt(e.target.dataset.actionBtnIndex);
        if (e.key === 'ArrowDown' && currentIndex + 1 < childrenLength) {
            e.preventDefault();
            actionBtnsRef.current.querySelector(`[data-action-btn-index="${currentIndex + 1}"]`).focus();
        }
        if (e.key === 'ArrowUp' && currentIndex > 0) {
            e.preventDefault();
            actionBtnsRef.current.querySelector(`[data-action-btn-index="${currentIndex - 1}"]`).focus();
        }
    };
    const displayHeader = isPhone();
    return createPortal(React.createElement(ResponsivePopover, Object.assign({ style: style, slot: slot, allowTargetOverlap: allowTargetOverlap, headerText: displayHeader ? headerText : undefined, horizontalAlign: horizontalAlign, initialFocus: initialFocus, modal: modal, hideArrow: hideArrow, placementType: placementType, verticalAlign: verticalAlign, footer: footer, header: displayHeader ? header : undefined, onAfterClose: onAfterClose, onBeforeClose: onBeforeClose, onBeforeOpen: onBeforeOpen, accessibleName: i18nBundle.getText(AVAILABLE_ACTIONS) }, rest, { onAfterOpen: handleAfterOpen, ref: componentRef, className: clsx(classes.actionSheet, isPhone() && classes.actionSheetMobile, className), "data-actionsheet": true }),
        React.createElement("div", { className: isPhone() ? classes.contentMobile : undefined, "data-component-name": "ActionSheetMobileContent", role: (_b = (_a = a11yConfig === null || a11yConfig === void 0 ? void 0 : a11yConfig.actionSheetMobileContent) === null || _a === void 0 ? void 0 : _a.role) !== null && _b !== void 0 ? _b : 'application', onKeyDown: handleKeyDown, ref: actionBtnsRef },
            childrenToRender.map(renderActionSheetButton),
            isPhone() && showCancelButton && (React.createElement(Button, { design: ButtonDesign.Negative, onClick: handleCancelBtnClick, tabIndex: focusedItem === childrenLength - 1 ? 0 : -1, "data-action-btn-index": childrenLength - 1, "data-cancel-btn": true, onFocus: setFocusedItem }, i18nBundle.getText(CANCEL))))), portalContainer);
});
ActionSheet.defaultProps = {
    showCancelButton: true,
    portalContainer: document.body
};
ActionSheet.displayName = 'ActionSheet';
export { ActionSheet };
