var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { debounce, enrichEventWithDetails, ThemingParameters, useIsRTL, useResponsiveContentPadding, useSyncRef } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { forwardRef, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { AvatarSize, GlobalStyleClasses, ObjectPageMode } from '../../enums';
import { addCustomCSSWithScoping } from '../../internal/addCustomCSSWithScoping';
import { safeGetChildrenArray } from '../../internal/safeGetChildrenArray';
import { useObserveHeights } from '../../internal/useObserveHeights';
import { Tab, TabContainer } from '../../webComponents';
import { DynamicPageCssVariables } from '../DynamicPage/DynamicPage.jss';
import { DynamicPageAnchorBar } from '../DynamicPageAnchorBar';
import { CollapsedAvatar } from './CollapsedAvatar';
import { ObjectPageCssVariables, styles } from './ObjectPage.jss';
import { extractSectionIdFromHtmlId, getLastObjectPageSection, getSectionById } from './ObjectPageUtils';
addCustomCSSWithScoping('ui5-tabcontainer', `
  :host([data-component-name="ObjectPageTabContainer"]) .ui5-tc__header {
    box-shadow: inset 0 -0.0625rem ${ThemingParameters.sapPageHeader_BorderColor}, 0 0.125rem 0.25rem 0 rgb(0 0 0 / 8%);
  }
  `);
const useStyles = createUseStyles(styles, { name: 'ObjectPage' });
/**
 * A component that allows apps to easily display information related to a business object.
 *
 * The `ObjectPage` is composed of a header (title and content) and block content wrapped in sections and subsections that structure the information.
 */
const ObjectPage = forwardRef((props, ref) => {
    var _a, _b, _c, _d, _e, _f;
    const { headerTitle, image, footer, mode, imageShapeCircle, className, style, slot, showHideHeaderButton, children, selectedSectionId, alwaysShowContentHeader, showTitleInHeaderContent, headerContent, headerContentPinnable, a11yConfig, placeholder, onSelectedSectionChange, onToggleHeaderContent } = props, rest = __rest(props, ["headerTitle", "image", "footer", "mode", "imageShapeCircle", "className", "style", "slot", "showHideHeaderButton", "children", "selectedSectionId", "alwaysShowContentHeader", "showTitleInHeaderContent", "headerContent", "headerContentPinnable", "a11yConfig", "placeholder", "onSelectedSectionChange", "onToggleHeaderContent"]);
    const classes = useStyles();
    const firstSectionId = (_b = (_a = safeGetChildrenArray(children)[0]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.id;
    const [internalSelectedSectionId, setInternalSelectedSectionId] = useState(selectedSectionId !== null && selectedSectionId !== void 0 ? selectedSectionId : firstSectionId);
    const [selectedSubSectionId, setSelectedSubSectionId] = useState(props.selectedSubSectionId);
    const [headerPinned, setHeaderPinned] = useState(alwaysShowContentHeader);
    const isProgrammaticallyScrolled = useRef(false);
    const [componentRef, objectPageRef] = useSyncRef(ref);
    const topHeaderRef = useRef(null);
    const scrollEvent = useRef();
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore
    const [componentRefHeaderContent, headerContentRef] = useSyncRef(headerContent === null || headerContent === void 0 ? void 0 : headerContent.ref);
    const anchorBarRef = useRef(null);
    const scrollTimeout = useRef(null);
    const [isAfterScroll, setIsAfterScroll] = useState(false);
    const isToggledRef = useRef(false);
    const prevInternalSelectedSectionId = useRef(internalSelectedSectionId);
    const fireOnSelectedChangedEvent = (targetEvent, index, id, section) => {
        if (typeof onSelectedSectionChange === 'function' && prevInternalSelectedSectionId.current !== id) {
            onSelectedSectionChange(enrichEventWithDetails(targetEvent, {
                selectedSectionIndex: parseInt(index, 10),
                selectedSectionId: id,
                section
            }));
            prevInternalSelectedSectionId.current = id;
        }
    };
    const debouncedOnSectionChange = useRef(debounce(fireOnSelectedChangedEvent, 500)).current;
    useEffect(() => {
        return () => {
            debouncedOnSectionChange.cancel();
            clearTimeout(scrollTimeout.current);
        };
    }, []);
    const isRTL = useIsRTL(objectPageRef);
    const responsivePaddingClass = useResponsiveContentPadding(objectPageRef.current);
    const [headerCollapsedInternal, setHeaderCollapsedInternal] = useState(undefined);
    // observe heights of header parts
    const { topHeaderHeight, headerContentHeight, anchorBarHeight, totalHeaderHeight, headerCollapsed } = useObserveHeights(objectPageRef, topHeaderRef, headerContentRef, anchorBarRef, [headerCollapsedInternal, setHeaderCollapsedInternal], {
        noHeader: !headerTitle && !headerContent,
        fixedHeader: headerPinned
    });
    useEffect(() => {
        if (typeof onToggleHeaderContent === 'function' && isToggledRef.current) {
            onToggleHeaderContent(headerCollapsed !== true);
        }
    }, [headerCollapsed]);
    const avatar = useMemo(() => {
        var _a;
        if (!image) {
            return null;
        }
        const headerImageClasses = clsx(classes.headerImage, isRTL && classes.headerImageRtl);
        if (typeof image === 'string') {
            return (React.createElement("span", { className: headerImageClasses, style: { borderRadius: imageShapeCircle ? '50%' : 0, overflow: 'hidden' } },
                React.createElement("img", { src: image, className: classes.image, alt: "Company Logo" })));
        }
        else {
            return React.cloneElement(image, {
                size: AvatarSize.L,
                className: clsx(headerImageClasses, (_a = image.props) === null || _a === void 0 ? void 0 : _a.className)
            });
        }
    }, [image, classes.headerImage, classes.headerImageRtl, classes.image, imageShapeCircle, isRTL]);
    const prevTopHeaderHeight = useRef(0);
    const scrollToSection = useCallback((sectionId) => {
        var _a, _b, _c, _d;
        if (!sectionId) {
            return;
        }
        if (firstSectionId === sectionId) {
            (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo({ top: 0, behavior: 'smooth' });
        }
        else {
            const childOffset = (_c = (_b = objectPageRef.current) === null || _b === void 0 ? void 0 : _b.querySelector(`#ObjectPageSection-${sectionId}`)) === null || _c === void 0 ? void 0 : _c.offsetTop;
            if (!isNaN(childOffset)) {
                const safeTopHeaderHeight = topHeaderHeight || prevTopHeaderHeight.current;
                if (topHeaderHeight) {
                    prevTopHeaderHeight.current = topHeaderHeight;
                }
                (_d = objectPageRef.current) === null || _d === void 0 ? void 0 : _d.scrollTo({
                    top: childOffset -
                        safeTopHeaderHeight -
                        anchorBarHeight -
                        (headerPinned ? (headerCollapsed === true ? 0 : headerContentHeight) : 0),
                    behavior: 'smooth'
                });
            }
        }
        isProgrammaticallyScrolled.current = false;
    }, [
        firstSectionId,
        objectPageRef,
        topHeaderHeight,
        anchorBarHeight,
        headerPinned,
        headerContentHeight,
        headerCollapsed,
        prevTopHeaderHeight.current
    ]);
    const programmaticallySetSection = () => {
        var _a;
        const currentId = selectedSectionId !== null && selectedSectionId !== void 0 ? selectedSectionId : firstSectionId;
        if (currentId !== prevSelectedSectionId.current) {
            debouncedOnSectionChange.cancel();
            isProgrammaticallyScrolled.current = true;
            setInternalSelectedSectionId(currentId);
            prevSelectedSectionId.current = currentId;
            const sections = (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('section[data-component-name="ObjectPageSection"]');
            const currentIndex = safeGetChildrenArray(children).findIndex((objectPageSection) => {
                var _a;
                return ((_a = objectPageSection.props) === null || _a === void 0 ? void 0 : _a.id) === currentId;
            });
            fireOnSelectedChangedEvent({}, currentIndex, currentId, sections[0]);
        }
    };
    // change selected section when prop is changed (external change)
    const prevSelectedSectionId = useRef();
    const [timeStamp, setTimeStamp] = useState(0);
    const requestAnimationFrameRef = useRef();
    useEffect(() => {
        if (selectedSectionId) {
            if (mode === ObjectPageMode.Default) {
                // wait for DOM draw, otherwise initial scroll won't work as intended
                if (timeStamp < 750 && timeStamp !== undefined) {
                    requestAnimationFrameRef.current = requestAnimationFrame((internalTimestamp) => {
                        setTimeStamp(internalTimestamp);
                    });
                }
                else {
                    setTimeStamp(undefined);
                    programmaticallySetSection();
                }
            }
            else {
                programmaticallySetSection();
            }
        }
        return () => {
            cancelAnimationFrame(requestAnimationFrameRef.current);
        };
    }, [timeStamp, selectedSectionId, firstSectionId, debouncedOnSectionChange]);
    // section was selected by clicking on the anchor bar buttons
    const handleOnSectionSelected = useCallback((targetEvent, newSelectionSectionId, index, section) => {
        isProgrammaticallyScrolled.current = true;
        debouncedOnSectionChange.cancel();
        setInternalSelectedSectionId((oldSelectedSection) => {
            if (oldSelectedSection === newSelectionSectionId) {
                scrollToSection(newSelectionSectionId);
            }
            return newSelectionSectionId;
        });
        scrollEvent.current = targetEvent;
        fireOnSelectedChangedEvent(targetEvent, index, newSelectionSectionId, section);
    }, [onSelectedSectionChange, setInternalSelectedSectionId, isProgrammaticallyScrolled, scrollToSection]);
    // do internal scrolling
    useEffect(() => {
        if (mode === ObjectPageMode.Default && isProgrammaticallyScrolled.current === true && !selectedSubSectionId) {
            scrollToSection(internalSelectedSectionId);
        }
    }, [internalSelectedSectionId, mode, isProgrammaticallyScrolled, scrollToSection, selectedSubSectionId]);
    // Scrolling for Sub Section Selection
    useEffect(() => {
        var _a, _b;
        if (selectedSubSectionId && isProgrammaticallyScrolled.current === true) {
            const currentSubSection = (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(`div[id="ObjectPageSubSection-${selectedSubSectionId}"]`);
            const childOffset = currentSubSection === null || currentSubSection === void 0 ? void 0 : currentSubSection.offsetTop;
            if (!isNaN(childOffset)) {
                currentSubSection.focus();
                (_b = objectPageRef.current) === null || _b === void 0 ? void 0 : _b.scrollTo({
                    top: childOffset -
                        topHeaderHeight -
                        anchorBarHeight -
                        48 /*tabBar*/ -
                        (headerPinned ? headerContentHeight : 0) -
                        16,
                    behavior: 'smooth'
                });
            }
            isProgrammaticallyScrolled.current = false;
        }
    }, [
        selectedSubSectionId,
        isProgrammaticallyScrolled.current,
        topHeaderHeight,
        anchorBarHeight,
        headerPinned,
        headerContentHeight
    ]);
    useEffect(() => {
        setHeaderPinned(alwaysShowContentHeader);
    }, [setHeaderPinned, alwaysShowContentHeader]);
    useEffect(() => {
        setSelectedSubSectionId(props.selectedSubSectionId);
        if (props.selectedSubSectionId) {
            isProgrammaticallyScrolled.current = true;
            if (mode === ObjectPageMode.IconTabBar) {
                let sectionId;
                safeGetChildrenArray(children).forEach((section) => {
                    if (React.isValidElement(section) && section.props && section.props.children) {
                        safeGetChildrenArray(section.props.children).forEach((subSection) => {
                            var _a;
                            if (React.isValidElement(subSection) &&
                                subSection.props &&
                                subSection.props.id === props.selectedSubSectionId) {
                                sectionId = (_a = section.props) === null || _a === void 0 ? void 0 : _a.id;
                            }
                        });
                    }
                });
                if (sectionId) {
                    setInternalSelectedSectionId(sectionId);
                }
            }
        }
    }, [props.selectedSubSectionId, setInternalSelectedSectionId, setSelectedSubSectionId, children, mode]);
    useEffect(() => {
        const fillerDivObserver = new ResizeObserver(() => {
            var _a, _b;
            let heightDiff = 0;
            const maxHeight = Math.min((_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight, window.innerHeight);
            const availableScrollHeight = maxHeight - totalHeaderHeight;
            const lastSectionDomRef = getLastObjectPageSection(objectPageRef, !!footer && mode === ObjectPageMode.IconTabBar);
            if (lastSectionDomRef) {
                const subSections = lastSectionDomRef.querySelectorAll('[id^="ObjectPageSubSection"]');
                let lastSubSectionHeight;
                if (subSections.length > 0) {
                    lastSubSectionHeight = subSections[subSections.length - 1].offsetHeight;
                }
                else {
                    lastSubSectionHeight =
                        lastSectionDomRef.offsetHeight -
                            lastSectionDomRef.querySelector("[role='heading']").offsetHeight;
                }
                heightDiff = Math.max(0, availableScrollHeight - lastSubSectionHeight);
                if (isNaN(heightDiff)) {
                    heightDiff = 0;
                }
            }
            const lastSectionMargin = footer ? `calc(${heightDiff}px + 1rem)` : `${heightDiff}px`;
            (_b = objectPageRef.current) === null || _b === void 0 ? void 0 : _b.style.setProperty(ObjectPageCssVariables.lastSectionMargin, lastSectionMargin);
        });
        fillerDivObserver.observe(objectPageRef.current);
        return () => {
            fillerDivObserver.disconnect();
        };
    }, [totalHeaderHeight, objectPageRef, children, mode, footer]);
    const handleOnSubSectionSelected = useCallback((e) => {
        var _a;
        isProgrammaticallyScrolled.current = true;
        if (mode === ObjectPageMode.IconTabBar) {
            const sectionId = e.detail.sectionId;
            setInternalSelectedSectionId(sectionId);
            const sections = (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('section[data-component-name="ObjectPageSection"]');
            const currentIndex = safeGetChildrenArray(children).findIndex((objectPageSection) => {
                var _a;
                return ((_a = objectPageSection.props) === null || _a === void 0 ? void 0 : _a.id) === sectionId;
            });
            debouncedOnSectionChange(e, currentIndex, sectionId, sections[currentIndex]);
        }
        const subSectionId = e.detail.subSectionId;
        setSelectedSubSectionId(subSectionId);
    }, [mode, setInternalSelectedSectionId, setSelectedSubSectionId, isProgrammaticallyScrolled, children]);
    const [scrolledHeaderExpanded, setScrolledHeaderExpanded] = useState(false);
    const scrollTimout = useRef(0);
    const onToggleHeaderContentVisibility = useCallback((e) => {
        var _a, _b;
        isToggledRef.current = true;
        scrollTimout.current = performance.now() + 500;
        if (!e.detail.visible) {
            setHeaderCollapsedInternal(true);
            (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.classList.add(classes.headerCollapsed);
        }
        else {
            setHeaderCollapsedInternal(false);
            setScrolledHeaderExpanded(true);
            (_b = objectPageRef.current) === null || _b === void 0 ? void 0 : _b.classList.remove(classes.headerCollapsed);
        }
    }, []);
    const objectPageClasses = clsx(classes.objectPage, GlobalStyleClasses.sapScrollBar, className, mode === ObjectPageMode.IconTabBar && classes.iconTabBarMode);
    const { onScroll: _0, selectedSubSectionId: _1 } = rest, propsWithoutOmitted = __rest(rest, ["onScroll", "selectedSubSectionId"]);
    useEffect(() => {
        var _a, _b, _c;
        const sections = (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('section[data-component-name="ObjectPageSection"]');
        const objectPageHeight = (_c = (_b = objectPageRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) !== null && _c !== void 0 ? _c : 1000;
        const marginBottom = objectPageHeight - totalHeaderHeight - /*TabContainer*/ 48;
        const rootMargin = `-${totalHeaderHeight}px 0px -${marginBottom < 0 ? 0 : marginBottom}px 0px`;
        const observer = new IntersectionObserver(([section]) => {
            if (section.isIntersecting && isProgrammaticallyScrolled.current === false) {
                if (objectPageRef.current.getBoundingClientRect().top + totalHeaderHeight + 48 <=
                    section.target.getBoundingClientRect().bottom) {
                    const currentId = extractSectionIdFromHtmlId(section.target.id);
                    setInternalSelectedSectionId(currentId);
                    const currentIndex = safeGetChildrenArray(children).findIndex((objectPageSection) => {
                        var _a;
                        return ((_a = objectPageSection.props) === null || _a === void 0 ? void 0 : _a.id) === currentId;
                    });
                    debouncedOnSectionChange(scrollEvent.current, currentIndex, currentId, section.target);
                }
            }
        }, {
            root: objectPageRef.current,
            rootMargin,
            threshold: [0]
        });
        // Fallback when scrolling faster than the IntersectionObserver can observe (in most cases faster than 60fps)
        if (isAfterScroll) {
            let currentSection = sections[sections.length - 1];
            let currentIndex;
            for (let i = 0; i <= sections.length - 1; i++) {
                const section = sections[i];
                if (objectPageRef.current.getBoundingClientRect().top + totalHeaderHeight + 48 <=
                    section.getBoundingClientRect().bottom) {
                    currentSection = section;
                    currentIndex = i;
                    break;
                }
            }
            const currentSectionId = extractSectionIdFromHtmlId(currentSection === null || currentSection === void 0 ? void 0 : currentSection.id);
            if (currentSectionId !== internalSelectedSectionId) {
                setInternalSelectedSectionId(currentSectionId);
                debouncedOnSectionChange(scrollEvent.current, currentIndex !== null && currentIndex !== void 0 ? currentIndex : sections.length - 1, currentSectionId, currentSection);
            }
            setIsAfterScroll(false);
        }
        sections.forEach((el) => {
            observer.observe(el);
        });
        return () => {
            observer.disconnect();
        };
    }, [
        objectPageRef.current,
        children,
        totalHeaderHeight,
        setInternalSelectedSectionId,
        isProgrammaticallyScrolled,
        isAfterScroll
    ]);
    const titleHeaderNotClickable = (alwaysShowContentHeader && !headerContentPinnable) ||
        !headerContent ||
        (!showHideHeaderButton && !headerContentPinnable);
    const onTitleClick = useCallback((e) => {
        e.stopPropagation();
        if (!titleHeaderNotClickable) {
            onToggleHeaderContentVisibility(enrichEventWithDetails(e, { visible: headerCollapsed }));
        }
    }, [onToggleHeaderContentVisibility, headerCollapsed, titleHeaderNotClickable]);
    const renderTitleSection = useCallback((inHeader = false) => {
        var _a, _b, _c;
        const titleStyles = Object.assign(Object.assign({}, (inHeader ? { padding: 0 } : {})), ((_b = (_a = headerTitle === null || headerTitle === void 0 ? void 0 : headerTitle.props) === null || _a === void 0 ? void 0 : _a.style) !== null && _b !== void 0 ? _b : {}));
        if ((headerTitle === null || headerTitle === void 0 ? void 0 : headerTitle.props) && ((_c = headerTitle.props) === null || _c === void 0 ? void 0 : _c.showSubHeaderRight) === undefined) {
            return React.cloneElement(headerTitle, {
                showSubHeaderRight: true,
                style: titleStyles,
                'data-not-clickable': titleHeaderNotClickable,
                onToggleHeaderContentVisibility: onTitleClick
            });
        }
        return React.cloneElement(headerTitle, {
            style: titleStyles,
            'data-not-clickable': titleHeaderNotClickable,
            onToggleHeaderContentVisibility: onTitleClick
        });
    }, [headerTitle, titleHeaderNotClickable, onTitleClick]);
    const renderHeaderContentSection = useCallback(() => {
        if (headerContent === null || headerContent === void 0 ? void 0 : headerContent.props) {
            return React.cloneElement(headerContent, Object.assign(Object.assign({}, headerContent.props), { topHeaderHeight, style: headerCollapsed === true ? { position: 'absolute', visibility: 'hidden' } : headerContent.props.style, headerPinned: headerPinned || scrolledHeaderExpanded, ref: componentRefHeaderContent, children: (React.createElement("div", { className: `${classes.headerContainer} ${responsivePaddingClass}`, "data-component-name": "ObjectPageHeaderContainer" },
                    avatar,
                    headerContent.props.children && (React.createElement("div", { "data-component-name": "ObjectPageHeaderContent" },
                        headerTitle && showTitleInHeaderContent && renderTitleSection(true),
                        headerContent.props.children)))) }));
        }
    }, [
        headerContent,
        topHeaderHeight,
        headerPinned,
        scrolledHeaderExpanded,
        showTitleInHeaderContent,
        avatar,
        headerContentRef,
        renderTitleSection,
        responsivePaddingClass
    ]);
    const paddingLeftRtl = isRTL ? 'paddingLeft' : 'paddingRight';
    const onTabItemSelect = (event) => {
        var _a;
        event.preventDefault();
        const { sectionId, index, isSubTab, parentId } = event.detail.tab.dataset;
        if (isSubTab) {
            handleOnSubSectionSelected(enrichEventWithDetails(event, { sectionId: parentId, subSectionId: sectionId }));
        }
        else {
            const section = safeGetChildrenArray(children).find((el) => {
                return el.props.id == sectionId;
            });
            handleOnSectionSelected(event, (_a = section === null || section === void 0 ? void 0 : section.props) === null || _a === void 0 ? void 0 : _a.id, index, section);
        }
    };
    const prevScrollTop = useRef();
    const onObjectPageScroll = useCallback((e) => {
        var _a;
        if (!isToggledRef.current) {
            isToggledRef.current = true;
        }
        if (scrollTimout.current >= performance.now()) {
            return;
        }
        scrollEvent.current = e;
        if (typeof props.onScroll === 'function') {
            props.onScroll(e);
        }
        if (selectedSubSectionId) {
            setSelectedSubSectionId(undefined);
        }
        if (scrollTimeout.current) {
            clearTimeout(scrollTimeout.current);
        }
        scrollTimeout.current = setTimeout(() => {
            setIsAfterScroll(true);
        }, 100);
        if (!headerPinned || e.target.scrollTop === 0) {
            (_a = objectPageRef.current) === null || _a === void 0 ? void 0 : _a.classList.remove(classes.headerCollapsed);
        }
        if (scrolledHeaderExpanded && e.target.scrollTop !== prevScrollTop.current) {
            if (e.target.scrollHeight - e.target.scrollTop === e.target.clientHeight) {
                return;
            }
            prevScrollTop.current = e.target.scrollTop;
            if (!headerPinned) {
                setHeaderCollapsedInternal(true);
            }
            setScrolledHeaderExpanded(false);
        }
    }, [topHeaderHeight, headerPinned, props.onScroll, scrolledHeaderExpanded, selectedSubSectionId]);
    const onHoverToggleButton = useCallback((e) => {
        var _a, _b;
        if ((e === null || e === void 0 ? void 0 : e.type) === 'mouseover') {
            (_a = topHeaderRef.current) === null || _a === void 0 ? void 0 : _a.classList.add(classes.headerHoverStyles);
        }
        else {
            (_b = topHeaderRef.current) === null || _b === void 0 ? void 0 : _b.classList.remove(classes.headerHoverStyles);
        }
    }, [classes.headerHoverStyles]);
    const objectPageStyles = Object.assign({}, style);
    if (headerCollapsed === true && headerContent) {
        objectPageStyles[DynamicPageCssVariables.titleFontSize] = ThemingParameters.sapObjectHeader_Title_SnappedFontSize;
    }
    return (React.createElement("div", Object.assign({ "data-component-name": "ObjectPage", slot: slot, className: objectPageClasses, style: objectPageStyles, ref: componentRef, onScroll: onObjectPageScroll }, propsWithoutOmitted),
        React.createElement("header", { onMouseOver: onHoverToggleButton, onMouseLeave: onHoverToggleButton, "data-component-name": "ObjectPageTopHeader", ref: topHeaderRef, role: (_d = (_c = a11yConfig === null || a11yConfig === void 0 ? void 0 : a11yConfig.objectPageTopHeader) === null || _c === void 0 ? void 0 : _c.role) !== null && _d !== void 0 ? _d : 'banner', "data-not-clickable": titleHeaderNotClickable, "aria-roledescription": (_f = (_e = a11yConfig === null || a11yConfig === void 0 ? void 0 : a11yConfig.objectPageTopHeader) === null || _e === void 0 ? void 0 : _e.ariaRoledescription) !== null && _f !== void 0 ? _f : 'Object Page header', className: `${classes.header} ${responsivePaddingClass}`, onClick: onTitleClick, style: {
                gridAutoColumns: `min-content ${headerTitle && image && headerCollapsed === true ? `calc(100% - 3rem - 1rem)` : '100%'}`,
                display: !showTitleInHeaderContent || headerCollapsed === true ? 'grid' : 'none'
            } },
            headerTitle && image && headerCollapsed === true && (React.createElement(CollapsedAvatar, { image: image, imageShapeCircle: imageShapeCircle, style: { [paddingLeftRtl]: '1rem' } })),
            headerTitle && renderTitleSection()),
        renderHeaderContentSection(),
        headerContent && headerTitle && (React.createElement("div", { "data-component-name": "ObjectPageAnchorBar", ref: anchorBarRef, className: classes.anchorBar, style: {
                top: scrolledHeaderExpanded || headerPinned
                    ? `${topHeaderHeight + (headerCollapsed === true ? 0 : headerContentHeight)}px`
                    : `${topHeaderHeight + 5}px`
            } },
            React.createElement(DynamicPageAnchorBar, { headerContentVisible: headerContent && headerCollapsed !== true, headerContentPinnable: headerContentPinnable, showHideHeaderButton: showHideHeaderButton, onToggleHeaderContentVisibility: onToggleHeaderContentVisibility, setHeaderPinned: setHeaderPinned, headerPinned: headerPinned, onHoverToggleButton: onHoverToggleButton, a11yConfig: a11yConfig }))),
        !placeholder && (React.createElement("div", { className: classes.tabContainer, "data-component-name": "ObjectPageTabContainer", style: {
                top: headerPinned || scrolledHeaderExpanded
                    ? `${topHeaderHeight + (headerCollapsed === true ? 0 : headerContentHeight)}px`
                    : `${topHeaderHeight}px`
            } },
            React.createElement(TabContainer, { collapsed: true, fixed: true, onTabSelect: onTabItemSelect, "data-component-name": "ObjectPageTabContainer", className: classes.tabContainerComponent }, safeGetChildrenArray(children).map((section, index) => {
                var _a, _b;
                if (!section.props)
                    return null;
                const subTabs = safeGetChildrenArray(section.props.children).filter((subSection) => { var _a; return ((_a = subSection === null || subSection === void 0 ? void 0 : subSection.type) === null || _a === void 0 ? void 0 : _a.displayName) === 'ObjectPageSubSection'; });
                return (React.createElement(Tab, { key: `Anchor-${(_a = section.props) === null || _a === void 0 ? void 0 : _a.id}`, "data-index": index, "data-section-id": section.props.id, text: section.props.titleText, selected: internalSelectedSectionId === ((_b = section.props) === null || _b === void 0 ? void 0 : _b.id) || undefined, subTabs: subTabs.map((item) => {
                        return (React.createElement(Tab, { "data-parent-id": section.props.id, key: item.props.id, "data-is-sub-tab": true, "data-section-id": item.props.id, text: item.props.titleText, selected: item.props.id === selectedSubSectionId || undefined },
                            React.createElement("span", { style: { display: 'none' } })));
                    }) },
                    React.createElement("span", { style: { display: 'none' } })));
            })))),
        React.createElement("div", { "data-component-name": "ObjectPageContent", className: responsivePaddingClass }, placeholder
            ? placeholder
            : mode === ObjectPageMode.IconTabBar
                ? getSectionById(children, internalSelectedSectionId)
                : children),
        footer && React.createElement("div", { style: { height: '1rem' }, "data-component-name": "ObjectPageFooterSpacer" }),
        footer && (React.createElement("footer", { className: classes.footer, "data-component-name": "ObjectPageFooter" }, footer))));
});
ObjectPage.displayName = 'ObjectPage';
ObjectPage.defaultProps = {
    image: null,
    mode: ObjectPageMode.Default,
    imageShapeCircle: false,
    showHideHeaderButton: false
};
export { ObjectPage };
