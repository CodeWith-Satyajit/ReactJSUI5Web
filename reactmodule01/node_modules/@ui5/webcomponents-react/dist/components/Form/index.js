var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { CssSizeVariables, Device, ThemingParameters, useSyncRef } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { Children, cloneElement, forwardRef, useEffect, useMemo, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { FormBackgroundDesign, TitleLevel } from '../../enums';
import { Title } from '../../webComponents/Title';
import { styles } from './Form.jss';
const clonedChildrenForSingleColumn = (reactChildren, currentLabelSpan) => React.Children.map(reactChildren, (child) => {
    var _a, _b;
    if (((_a = child === null || child === void 0 ? void 0 : child.type) === null || _a === void 0 ? void 0 : _a.displayName) === 'FormItem') {
        return cloneElement(child, { labelSpan: currentLabelSpan });
    }
    if (((_b = child === null || child === void 0 ? void 0 : child.type) === null || _b === void 0 ? void 0 : _b.displayName) === 'FormGroup') {
        return cloneElement(child, { children: clonedChildrenForSingleColumn(child.props.children, currentLabelSpan) });
    }
    return child;
});
const useStyles = createUseStyles(styles, { name: 'Form' });
/**
 * The `Form` component arranges labels and fields into groups and rows. There are different ways to visualize forms for different screen sizes.
 * It is possible to change the alignment of all labels by setting the CSS `align-items` property, per default all labels are centered.
 */
const Form = forwardRef((props, ref) => {
    var _a, _b;
    const { as, backgroundDesign, children, columnsS, columnsM, columnsL, columnsXL, className, labelSpanS, labelSpanM, labelSpanL, labelSpanXL, slot, titleText, style } = props, rest = __rest(props, ["as", "backgroundDesign", "children", "columnsS", "columnsM", "columnsL", "columnsXL", "className", "labelSpanS", "labelSpanM", "labelSpanL", "labelSpanXL", "slot", "titleText", "style"]);
    const columnsMap = new Map();
    columnsMap.set('Phone', columnsS);
    columnsMap.set('Tablet', columnsM);
    columnsMap.set('Desktop', columnsL);
    columnsMap.set('LargeDesktop', columnsXL);
    const labelSpanMap = new Map();
    labelSpanMap.set('Phone', labelSpanS);
    labelSpanMap.set('Tablet', labelSpanM);
    labelSpanMap.set('Desktop', labelSpanL);
    labelSpanMap.set('LargeDesktop', labelSpanXL);
    const [componentRef, formRef] = useSyncRef(ref);
    // use the window range set as first best guess, if not available use Desktop
    const [currentRange, setCurrentRange] = useState((_b = (_a = Device.getCurrentRange()) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'Desktop');
    const lastRange = useRef(currentRange);
    useEffect(() => {
        const observer = new ResizeObserver(([form]) => {
            const rangeInfo = Device.getCurrentRange(form.contentRect.width);
            if (rangeInfo && lastRange.current !== rangeInfo.name) {
                lastRange.current = rangeInfo.name;
                setCurrentRange(rangeInfo.name);
            }
        });
        if (formRef.current) {
            observer.observe(formRef.current);
        }
        return () => {
            observer.disconnect();
        };
    }, [formRef, setCurrentRange, lastRange]);
    const classes = useStyles();
    const currentNumberOfColumns = columnsMap.get(currentRange);
    const currentLabelSpan = labelSpanMap.get(currentRange);
    const [formGroups, updatedTitle] = useMemo(() => {
        var _a, _b;
        const computedFormGroups = [];
        if (Children.count(children) === 1 && !titleText) {
            const singleChild = (Array.isArray(children) ? children[0] : children);
            if (((_b = (_a = singleChild === null || singleChild === void 0 ? void 0 : singleChild.props) === null || _a === void 0 ? void 0 : _a.title) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                return [cloneElement(singleChild, { title: null }), singleChild.props.title];
            }
        }
        const currentColumnCount = currentNumberOfColumns;
        if (currentColumnCount === 1) {
            return [clonedChildrenForSingleColumn(children, currentLabelSpan), titleText];
        }
        const rows = [];
        const childrenArray = Children.toArray(children);
        const estimatedNumberOfGroupRows = childrenArray.length / currentColumnCount;
        for (let i = 0; i < estimatedNumberOfGroupRows; i++) {
            rows[i] = childrenArray.slice(i * currentColumnCount, i * currentColumnCount + currentColumnCount);
        }
        const maxRowsPerRow = [];
        rows.forEach((rowGroup, rowIndex) => {
            const numberOfRowsOfEachForm = rowGroup.map((row) => {
                if (row.type.displayName === 'FormItem') {
                    return 1;
                }
                return Children.count(row.props.children) + 1;
            });
            maxRowsPerRow[rowIndex] = Math.max(...numberOfRowsOfEachForm);
        });
        let totalRowCount = 2;
        rows.forEach((column, rowIndex) => {
            const rowsForThisRow = maxRowsPerRow[rowIndex];
            column.forEach((cell, columnIndex) => {
                var _a;
                const titleStyles = {
                    gridColumnEnd: 'span 12',
                    gridColumnStart: columnIndex * 12 + 1,
                    gridRowStart: totalRowCount,
                    display: 'flex',
                    alignItems: 'center',
                    fontFamily: ThemingParameters.sapFontFamily,
                    height: CssSizeVariables.sapWcrFormGroupTitleHeight,
                    lineHeight: CssSizeVariables.sapWcrFormGroupTitleHeight,
                    color: ThemingParameters.sapTextColor,
                    fontSize: ThemingParameters.sapFontSize,
                    fontWeight: 'bold',
                    backgroundColor: ThemingParameters.sapGroup_TitleBackground,
                    margin: 0,
                    paddingTop: '1rem'
                };
                if ((_a = cell === null || cell === void 0 ? void 0 : cell.props) === null || _a === void 0 ? void 0 : _a.titleText) {
                    computedFormGroups.push(React.createElement("h6", { style: titleStyles, title: cell.props.titleText, "aria-label": cell.props.titleText, key: `title-col-${columnIndex}-row-${totalRowCount}` }, cell.props.titleText));
                }
                for (let i = 0; i < rowsForThisRow; i++) {
                    const itemToRender = cell.type.displayName === 'FormGroup'
                        ? Children.toArray(cell.props.children)[i]
                        : cell.type.displayName === 'FormItem' && i === 0
                            ? cell
                            : null;
                    if (itemToRender) {
                        computedFormGroups.push(cloneElement(itemToRender, {
                            key: `col-${columnIndex}-row-${totalRowCount + i}`,
                            columnIndex,
                            lastGroupItem: cell.type.displayName === 'FormGroup' && rowsForThisRow - 2 === i,
                            rowIndex: totalRowCount + i + 1,
                            labelSpan: currentLabelSpan
                        }));
                    }
                }
            });
            totalRowCount += rowsForThisRow;
            if (rowsForThisRow === 1) {
                totalRowCount += 1;
            }
        });
        return [computedFormGroups, titleText];
    }, [children, currentRange, titleText, currentNumberOfColumns, currentLabelSpan]);
    const formClassNames = clsx(classes.form, classes[`labelSpan${((currentLabelSpan - 1) % 12) + 1}`], classes[backgroundDesign.toLowerCase()], className);
    const CustomTag = as;
    return (React.createElement(CustomTag, Object.assign({ ref: componentRef, slot: slot, className: formClassNames, style: style, "data-columns": currentNumberOfColumns }, rest),
        updatedTitle && (React.createElement(Title, { level: TitleLevel.H3, className: classes.formTitle }, updatedTitle)),
        formGroups));
});
Form.displayName = 'Form';
Form.defaultProps = {
    as: 'form',
    backgroundDesign: FormBackgroundDesign.Transparent,
    columnsS: 1,
    columnsM: 1,
    columnsL: 1,
    columnsXL: 2,
    labelSpanS: 12,
    labelSpanM: 2,
    labelSpanL: 4,
    labelSpanXL: 4
};
export { Form };
