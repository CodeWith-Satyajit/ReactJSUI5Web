var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { debounce, enrichEventWithDetails, ThemingParameters, useResponsiveContentPadding, useSyncRef } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { cloneElement, forwardRef, useEffect, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { GlobalStyleClasses, PageBackgroundDesign } from '../../enums';
import { useObserveHeights } from '../../internal/useObserveHeights';
import { DynamicPageAnchorBar } from '../DynamicPageAnchorBar';
import { FlexBox } from '../FlexBox';
import { DynamicPageCssVariables, styles } from './DynamicPage.jss';
/**
 * Defines the current state of the component.
 */
var HEADER_STATES;
(function (HEADER_STATES) {
    HEADER_STATES["AUTO"] = "AUTO";
    HEADER_STATES["VISIBLE_PINNED"] = "VISIBLE_PINNED";
    HEADER_STATES["HIDDEN_PINNED"] = "HIDDEN_PINNED";
    HEADER_STATES["VISIBLE"] = "VISIBLE";
    HEADER_STATES["HIDDEN"] = "HIDDEN";
})(HEADER_STATES || (HEADER_STATES = {}));
const useStyles = createUseStyles(styles, { name: 'DynamicPage' });
/**
 * The dynamic page is a generic layout control designed to support various floorplans and use cases.
 * The content of both the header and the page can differ from floorplan to floorplan.
 *
 * The header of the dynamic page is collapsible, which helps users to focus on the actual page content, but still ensures that important header information
 * and actions are readily available.
 */
const DynamicPage = forwardRef((props, ref) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { headerTitle, headerContent, style, backgroundDesign, showHideHeaderButton, headerContentPinnable, alwaysShowContentHeader, children, className, footer, a11yConfig, onToggleHeaderContent } = props, rest = __rest(props, ["headerTitle", "headerContent", "style", "backgroundDesign", "showHideHeaderButton", "headerContentPinnable", "alwaysShowContentHeader", "children", "className", "footer", "a11yConfig", "onToggleHeaderContent"]);
    const { onScroll: _1 } = rest, propsWithoutOmitted = __rest(rest, ["onScroll"]);
    const anchorBarRef = useRef(null);
    const [componentRef, dynamicPageRef] = useSyncRef(ref);
    const contentRef = useRef(null);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const [componentRefTopHeader, topHeaderRef] = useSyncRef(headerTitle === null || headerTitle === void 0 ? void 0 : headerTitle.ref);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const [componentRefHeaderContent, headerContentRef] = useSyncRef(headerContent === null || headerContent === void 0 ? void 0 : headerContent.ref);
    const [headerState, setHeaderState] = useState(alwaysShowContentHeader ? HEADER_STATES.VISIBLE_PINNED : HEADER_STATES.AUTO);
    const isToggledRef = useRef(false);
    const [isOverflowing, setIsOverflowing] = useState(false);
    const [headerCollapsedInternal, setHeaderCollapsedInternal] = useState(undefined);
    // observe heights of header parts
    const { topHeaderHeight, headerCollapsed } = useObserveHeights(dynamicPageRef, topHeaderRef, headerContentRef, anchorBarRef, [headerCollapsedInternal, setHeaderCollapsedInternal], {
        noHeader: false,
        fixedHeader: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.HIDDEN_PINNED
    });
    const classes = useStyles();
    const dynamicPageClasses = clsx(classes.dynamicPage, GlobalStyleClasses.sapScrollBar, classes[`background${backgroundDesign}`], className, [HEADER_STATES.HIDDEN, HEADER_STATES.HIDDEN_PINNED].includes(headerState) && classes.headerCollapsed);
    useEffect(() => {
        const debouncedObserverFn = debounce(([element]) => {
            setIsOverflowing(!element.isIntersecting);
        }, 250);
        const observer = new IntersectionObserver(debouncedObserverFn, {
            root: dynamicPageRef.current,
            threshold: 0.98,
            rootMargin: '0px 0px -60px 0px' // negative bottom margin for footer height
        });
        if (contentRef.current) {
            observer.observe(contentRef.current);
        }
        return () => {
            observer.disconnect();
            debouncedObserverFn.cancel();
        };
    }, []);
    useEffect(() => {
        var _a;
        const oneTimeScrollHandler = () => {
            setHeaderState(HEADER_STATES.AUTO);
            setHeaderCollapsedInternal(true);
        };
        if (headerState === HEADER_STATES.VISIBLE || headerState === HEADER_STATES.HIDDEN) {
            (_a = dynamicPageRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', oneTimeScrollHandler, { once: true });
        }
        return () => {
            var _a;
            (_a = dynamicPageRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', oneTimeScrollHandler);
        };
    }, [dynamicPageRef, headerState]);
    const onToggleHeaderContentVisibility = (e) => {
        const shouldHideHeader = !e.detail.visible;
        setHeaderState((oldState) => {
            if (oldState === HEADER_STATES.VISIBLE_PINNED || oldState === HEADER_STATES.HIDDEN_PINNED) {
                return shouldHideHeader ? HEADER_STATES.HIDDEN_PINNED : HEADER_STATES.VISIBLE_PINNED;
            }
            return shouldHideHeader ? HEADER_STATES.HIDDEN : HEADER_STATES.VISIBLE;
        });
    };
    useEffect(() => {
        if (headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE) {
            setHeaderCollapsedInternal(false);
        }
        else if (headerState === HEADER_STATES.HIDDEN_PINNED || headerState === HEADER_STATES.HIDDEN) {
            setHeaderCollapsedInternal(true);
        }
    }, [headerState]);
    const onHoverToggleButton = (e) => {
        if (topHeaderRef.current) {
            topHeaderRef.current.style.backgroundColor =
                (e === null || e === void 0 ? void 0 : e.type) === 'mouseover' ? ThemingParameters.sapObjectHeader_Hover_Background : null;
        }
    };
    const onToggleHeaderContentInternal = (e) => {
        e.stopPropagation();
        if (!isToggledRef.current) {
            isToggledRef.current = true;
        }
        onToggleHeaderContentVisibility(enrichEventWithDetails(e, { visible: headerCollapsed }));
    };
    const handleHeaderPinnedChange = (headerWillPin) => {
        if (headerWillPin) {
            setHeaderState(HEADER_STATES.VISIBLE_PINNED);
        }
        else {
            setHeaderState(HEADER_STATES.VISIBLE);
        }
    };
    useEffect(() => {
        if (alwaysShowContentHeader) {
            setHeaderState(HEADER_STATES.VISIBLE_PINNED);
        }
    }, [alwaysShowContentHeader, setHeaderState]);
    const responsivePaddingClass = useResponsiveContentPadding(dynamicPageRef.current);
    const onDynamicPageScroll = (e) => {
        if (!isToggledRef.current) {
            isToggledRef.current = true;
        }
        if (typeof (props === null || props === void 0 ? void 0 : props.onScroll) === 'function') {
            props.onScroll(e);
        }
        if (headerState === HEADER_STATES.HIDDEN_PINNED && e.target.scrollTop === 0) {
            setHeaderState(HEADER_STATES.VISIBLE_PINNED);
        }
    };
    const dynamicPageStyles = Object.assign({}, style);
    if (headerCollapsed === true && headerContent) {
        dynamicPageStyles[DynamicPageCssVariables.titleFontSize] = ThemingParameters.sapObjectHeader_Title_SnappedFontSize;
    }
    useEffect(() => {
        if (typeof onToggleHeaderContent === 'function' && isToggledRef.current) {
            onToggleHeaderContent(headerCollapsed !== true);
        }
    }, [headerCollapsed]);
    return (React.createElement("div", Object.assign({ ref: componentRef, className: dynamicPageClasses, style: dynamicPageStyles, onScroll: onDynamicPageScroll }, propsWithoutOmitted),
        headerTitle &&
            cloneElement(headerTitle, {
                'data-not-clickable': (alwaysShowContentHeader && !headerContentPinnable) ||
                    !headerContent ||
                    (!showHideHeaderButton && !headerContentPinnable),
                ref: componentRefTopHeader,
                className: ((_a = headerTitle === null || headerTitle === void 0 ? void 0 : headerTitle.props) === null || _a === void 0 ? void 0 : _a.className)
                    ? `${responsivePaddingClass} ${headerTitle.props.className}`
                    : responsivePaddingClass,
                onToggleHeaderContentVisibility: onToggleHeaderContentInternal
            }),
        headerContent &&
            cloneElement(headerContent, {
                ref: componentRefHeaderContent,
                style: headerCollapsed === true ? { position: 'absolute', visibility: 'hidden' } : headerContent.props.style,
                className: headerContent.props.className
                    ? `${responsivePaddingClass} ${headerContent.props.className}`
                    : responsivePaddingClass,
                headerPinned: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE,
                topHeaderHeight
            }),
        React.createElement(FlexBox, { "data-component-name": "DynamicPageAnchorBarContainer", className: classes.anchorBar, ref: anchorBarRef, style: {
                top: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE
                    ? ((_c = (_b = headerContentRef === null || headerContentRef === void 0 ? void 0 : headerContentRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) !== null && _c !== void 0 ? _c : 0) + topHeaderHeight
                    : topHeaderHeight
            } },
            React.createElement(DynamicPageAnchorBar, { headerContentPinnable: headerContentPinnable, showHideHeaderButton: showHideHeaderButton, headerContentVisible: headerContent && headerCollapsed !== true, onToggleHeaderContentVisibility: onToggleHeaderContentVisibility, setHeaderPinned: handleHeaderPinnedChange, headerPinned: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.HIDDEN_PINNED, onHoverToggleButton: onHoverToggleButton, a11yConfig: a11yConfig })),
        React.createElement("div", { ref: contentRef, "data-component-name": "DynamicPageContent", className: `${classes.contentContainer} ${responsivePaddingClass}`, style: {
                paddingBottom: footer ? '1rem' : 0
            } }, children),
        footer && (React.createElement("div", { className: classes.footer, style: { position: isOverflowing ? 'sticky' : 'absolute' }, "data-component-name": "DynamicPageFooter", role: (_e = (_d = a11yConfig === null || a11yConfig === void 0 ? void 0 : a11yConfig.dynamicPageFooter) === null || _d === void 0 ? void 0 : _d.role) !== null && _e !== void 0 ? _e : 'contentinfo', "aria-label": (_f = a11yConfig === null || a11yConfig === void 0 ? void 0 : a11yConfig.dynamicPageFooter) === null || _f === void 0 ? void 0 : _f['aria-label'], "aria-labelledby": (_g = a11yConfig === null || a11yConfig === void 0 ? void 0 : a11yConfig.dynamicPageFooter) === null || _g === void 0 ? void 0 : _g['aria-labelledby'] }, footer))));
});
DynamicPage.displayName = 'DynamicPage';
DynamicPage.defaultProps = {
    backgroundDesign: PageBackgroundDesign.Solid,
    showHideHeaderButton: true,
    headerContentPinnable: true
};
export { DynamicPage };
