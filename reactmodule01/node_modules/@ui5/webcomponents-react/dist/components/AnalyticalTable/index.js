var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useVirtualizer } from '@tanstack/react-virtual';
import { debounce, enrichEventWithDetails, useI18nBundle, useIsomorphicId, useIsomorphicLayoutEffect, useIsRTL } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { forwardRef, useCallback, useEffect, useMemo, useRef } from 'react';
import { createUseStyles } from 'react-jss';
import { useColumnOrder, useExpanded, useFilters, useGlobalFilter, useGroupBy, useResizeColumns, useRowSelect, useSortBy, useTable } from 'react-table';
import { GlobalStyleClasses, TableScaleWidthMode, TableSelectionBehavior, TableSelectionMode, TableVisibleRowCountMode } from '../../enums';
import { COLLAPSE_NODE, COLLAPSE_PRESS_SPACE, EXPAND_NODE, EXPAND_PRESS_SPACE, INVALID_TABLE, SELECT_PRESS_SPACE, UNSELECT_PRESS_SPACE } from '../../i18n/i18n-defaults';
import { FlexBox } from '../FlexBox';
import { Text } from '../Text';
import styles from './AnayticalTable.jss';
import { ColumnHeaderContainer } from './ColumnHeader/ColumnHeaderContainer';
import { DefaultColumn } from './defaults/Column';
import { DefaultLoadingComponent } from './defaults/LoadingComponent';
import { TablePlaceholder } from './defaults/LoadingComponent/TablePlaceholder';
import { DefaultNoDataComponent } from './defaults/NoDataComponent';
import { useA11y } from './hooks/useA11y';
import { useDragAndDrop } from './hooks/useDragAndDrop';
import { useDynamicColumnWidths } from './hooks/useDynamicColumnWidths';
import { useKeyboardNavigation } from './hooks/useKeyboardNavigation';
import { usePopIn } from './hooks/usePopIn';
import { useResizeColumnsConfig } from './hooks/useResizeColumnsConfig';
import { useRowHighlight } from './hooks/useRowHighlight';
import { useRowNavigationIndicators } from './hooks/useRowNavigationIndicator';
import { useRowSelectionColumn } from './hooks/useRowSelectionColumn';
import { useSelectionChangeCallback } from './hooks/useSelectionChangeCallback';
import { useSingleRowStateSelection } from './hooks/useSingleRowStateSelection';
import { useStyling } from './hooks/useStyling';
import { useTableScrollHandles } from './hooks/useTableScrollHandles';
import { useToggleRowExpand } from './hooks/useToggleRowExpand';
import { useVisibleColumnsWidth } from './hooks/useVisibleColumnsWidth';
import { VerticalScrollbar } from './scrollbars/VerticalScrollbar';
import { VirtualTableBody } from './TableBody/VirtualTableBody';
import { VirtualTableBodyContainer } from './TableBody/VirtualTableBodyContainer';
import { stateReducer } from './tableReducer/stateReducer';
import { TitleBar } from './TitleBar';
import { orderByFn, tagNamesWhichShouldNotSelectARow } from './util';
import { VerticalResizer } from './VerticalResizer';
// When a sorted column is removed from the visible columns array (e.g. when "popped-in"), it doesn't clean up the sorted columns leading to an undefined `sortType`.
const sortTypesFallback = {
    undefined: () => undefined
};
const useStyles = createUseStyles(styles, { name: 'AnalyticalTable' });
/**
 * The `AnalyticalTable` provides a set of convenient functions for responsive table design, including virtualization of rows and columns, infinite scrolling and customizable columns that will, unless otherwise defined, distribute the available space equally among themselves.
 * It also provides several possibilities for working with the data, including sorting, filtering, grouping and aggregation.
 */
const AnalyticalTable = forwardRef((props, ref) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const { alternateRowColor, alwaysShowSubComponent, adjustTableHeightOnPopIn, className, columnOrder, columns, data: rawData, extension, filterable, globalFilterValue, groupBy, groupable, header, headerRowHeight, highlightField, infiniteScroll, infiniteScrollThreshold, isTreeTable, loading, markNavigatedRow, minRows, noDataText, overscanCount, overscanCountHorizontal, portalContainer, retainColumnWidth, reactTableOptions, renderRowSubComponent, rowHeight, scaleWidthMode, selectedRowIds, selectionBehavior, selectionMode, showOverlay, sortable, style, subRowsKey, tableHooks, tableInstance, visibleRowCountMode, visibleRows, withNavigationHighlight, withRowHighlight, onColumnsReorder, onGroup, onLoadMore, onRowClick, onRowExpandChange, onRowSelect, onSort, onTableScroll, LoadingComponent, NoDataComponent, scaleXFactor } = props, rest = __rest(props, ["alternateRowColor", "alwaysShowSubComponent", "adjustTableHeightOnPopIn", "className", "columnOrder", "columns", "data", "extension", "filterable", "globalFilterValue", "groupBy", "groupable", "header", "headerRowHeight", "highlightField", "infiniteScroll", "infiniteScrollThreshold", "isTreeTable", "loading", "markNavigatedRow", "minRows", "noDataText", "overscanCount", "overscanCountHorizontal", "portalContainer", "retainColumnWidth", "reactTableOptions", "renderRowSubComponent", "rowHeight", "scaleWidthMode", "selectedRowIds", "selectionBehavior", "selectionMode", "showOverlay", "sortable", "style", "subRowsKey", "tableHooks", "tableInstance", "visibleRowCountMode", "visibleRows", "withNavigationHighlight", "withRowHighlight", "onColumnsReorder", "onGroup", "onLoadMore", "onRowClick", "onRowExpandChange", "onRowSelect", "onSort", "onTableScroll", "LoadingComponent", "NoDataComponent", "scaleXFactor"]);
    const uniqueId = useIsomorphicId();
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    const titleBarId = useRef(`titlebar-${uniqueId}`).current;
    const invalidTableTextId = useRef(`invalidTableText-${uniqueId}`).current;
    const classes = useStyles();
    const [analyticalTableRef, scrollToRef] = useTableScrollHandles(ref);
    const tableRef = useRef(null);
    const isRtl = useIsRTL(analyticalTableRef);
    const getSubRows = useCallback((row) => row.subRows || row[subRowsKey] || [], [subRowsKey]);
    const data = useMemo(() => {
        if (rawData.length === 0) {
            return rawData;
        }
        if (minRows > rawData.length) {
            const missingRows = minRows - rawData.length;
            const emptyRows = Array.from({ length: missingRows }, (v, i) => i).map(() => ({ emptyRow: true }));
            return [...rawData, ...emptyRows];
        }
        return rawData;
    }, [rawData, minRows]);
    const invalidTableA11yText = i18nBundle.getText(INVALID_TABLE);
    const tableInstanceRef = useRef(null);
    tableInstanceRef.current = useTable(Object.assign({ columns,
        data, defaultColumn: DefaultColumn, orderByFn,
        getSubRows,
        stateReducer, disableFilters: !filterable, disableSortBy: !sortable, disableGroupBy: isTreeTable || renderRowSubComponent ? true : !groupable, selectSubRows: false, sortTypes: sortTypesFallback, webComponentsReactProperties: {
            translatableTexts: {
                expandA11yText: i18nBundle.getText(EXPAND_PRESS_SPACE),
                collapseA11yText: i18nBundle.getText(COLLAPSE_PRESS_SPACE),
                selectA11yText: i18nBundle.getText(SELECT_PRESS_SPACE),
                unselectA11yText: i18nBundle.getText(UNSELECT_PRESS_SPACE),
                expandNodeA11yText: i18nBundle.getText(EXPAND_NODE),
                collapseNodeA11yText: i18nBundle.getText(COLLAPSE_NODE)
            },
            tagNamesWhichShouldNotSelectARow,
            tableRef,
            selectionMode,
            selectionBehavior,
            classes,
            onRowSelect: onRowSelect,
            onRowClick,
            onRowExpandChange,
            isTreeTable,
            alternateRowColor,
            scaleWidthMode,
            loading,
            withRowHighlight,
            highlightField,
            withNavigationHighlight,
            markNavigatedRow,
            renderRowSubComponent,
            alwaysShowSubComponent,
            scrollToRef,
            showOverlay,
            uniqueId,
            scaleXFactor
        } }, reactTableOptions), useFilters, useGlobalFilter, useColumnOrder, useGroupBy, useSortBy, useExpanded, useRowSelect, useResizeColumns, useResizeColumnsConfig, useRowSelectionColumn, useSingleRowStateSelection, useSelectionChangeCallback, useRowHighlight, useRowNavigationIndicators, useDynamicColumnWidths, useStyling, useToggleRowExpand, useA11y, usePopIn, useVisibleColumnsWidth, useKeyboardNavigation, ...tableHooks);
    const { getTableProps, headerGroups, rows, prepareRow, state: tableState, columns: tableInternalColumns, setColumnOrder, dispatch, totalColumnsWidth, visibleColumns, visibleColumnsWidth, setGroupBy, setGlobalFilter } = tableInstanceRef.current;
    if (tableInstance && {}.hasOwnProperty.call(tableInstance, 'current')) {
        tableInstance.current = tableInstanceRef.current;
    }
    if (typeof tableInstance === 'function') {
        tableInstance(tableInstanceRef.current);
    }
    const titleBarRef = useRef(null);
    const extensionRef = useRef(null);
    const headerRef = useRef(null);
    const extensionsHeight = ((_b = (_a = titleBarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0) +
        ((_d = (_c = extensionRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0) +
        ((_f = (_e = headerRef.current) === null || _e === void 0 ? void 0 : _e.offsetHeight) !== null && _f !== void 0 ? _f : 0);
    const calcRowHeight = parseInt(getComputedStyle((_g = tableRef.current) !== null && _g !== void 0 ? _g : document.body).getPropertyValue('--sapWcrAnalyticalTableRowHeight') || '44');
    const internalRowHeight = rowHeight !== null && rowHeight !== void 0 ? rowHeight : calcRowHeight;
    const internalHeaderRowHeight = headerRowHeight !== null && headerRowHeight !== void 0 ? headerRowHeight : internalRowHeight;
    const popInRowHeight = ((_h = tableState === null || tableState === void 0 ? void 0 : tableState.popInColumns) === null || _h === void 0 ? void 0 : _h.length) > 0
        ? internalRowHeight + tableState.popInColumns.length * (internalRowHeight + 16)
        : internalRowHeight;
    const internalVisibleRowCount = (_j = tableState.visibleRows) !== null && _j !== void 0 ? _j : visibleRows;
    const updateTableClientWidth = useCallback(() => {
        if (tableRef.current) {
            dispatch({ type: 'TABLE_RESIZE', payload: { tableClientWidth: tableRef.current.clientWidth } });
        }
    }, [tableRef.current]);
    const updateRowsCount = useCallback(() => {
        var _a, _b, _c, _d;
        if (visibleRowCountMode === TableVisibleRowCountMode.Auto && ((_a = analyticalTableRef.current) === null || _a === void 0 ? void 0 : _a.parentElement)) {
            const parentElement = (_b = analyticalTableRef.current) === null || _b === void 0 ? void 0 : _b.parentElement;
            const tableYPosition = parentElement &&
                getComputedStyle(parentElement).position === 'relative' &&
                ((_c = analyticalTableRef.current) === null || _c === void 0 ? void 0 : _c.offsetTop)
                ? (_d = analyticalTableRef.current) === null || _d === void 0 ? void 0 : _d.offsetTop
                : 0;
            const parentHeight = parentElement === null || parentElement === void 0 ? void 0 : parentElement.getBoundingClientRect().height;
            const tableHeight = parentHeight ? parentHeight - tableYPosition : 0;
            const rowCount = Math.max(1, Math.floor((tableHeight - extensionsHeight) / popInRowHeight));
            dispatch({
                type: 'VISIBLE_ROWS',
                payload: { visibleRows: rowCount }
            });
        }
    }, [
        (_l = (_k = analyticalTableRef.current) === null || _k === void 0 ? void 0 : _k.parentElement) === null || _l === void 0 ? void 0 : _l.getBoundingClientRect().height,
        (_m = analyticalTableRef.current) === null || _m === void 0 ? void 0 : _m.getBoundingClientRect().y,
        extensionsHeight,
        popInRowHeight,
        visibleRowCountMode
    ]);
    useEffect(() => {
        setGlobalFilter(globalFilterValue);
    }, [globalFilterValue, setGlobalFilter]);
    useEffect(() => {
        var _a, _b;
        const debouncedWidthObserverFn = debounce(updateTableClientWidth, 500);
        const tableWidthObserver = new ResizeObserver(debouncedWidthObserverFn);
        tableWidthObserver.observe(tableRef.current);
        const debouncedHeightObserverFn = debounce(updateRowsCount, 500);
        const parentHeightObserver = new ResizeObserver(debouncedHeightObserverFn);
        if ((_a = analyticalTableRef.current) === null || _a === void 0 ? void 0 : _a.parentElement) {
            parentHeightObserver.observe((_b = analyticalTableRef.current) === null || _b === void 0 ? void 0 : _b.parentElement);
        }
        return () => {
            debouncedHeightObserverFn.cancel();
            debouncedWidthObserverFn.cancel();
            tableWidthObserver.disconnect();
            parentHeightObserver.disconnect();
        };
    }, [updateTableClientWidth, updateRowsCount]);
    useIsomorphicLayoutEffect(() => {
        dispatch({ type: 'IS_RTL', payload: { isRtl } });
    }, [isRtl]);
    useIsomorphicLayoutEffect(() => {
        updateTableClientWidth();
    }, [updateTableClientWidth]);
    useIsomorphicLayoutEffect(() => {
        updateRowsCount();
    }, [updateRowsCount]);
    useEffect(() => {
        if (tableState.visibleRows !== undefined && visibleRowCountMode === TableVisibleRowCountMode.Fixed) {
            dispatch({
                type: 'VISIBLE_ROWS',
                payload: { visibleRows: undefined }
            });
        }
    }, [visibleRowCountMode, tableState.visibleRows]);
    useEffect(() => {
        setGroupBy(groupBy);
    }, [groupBy, setGroupBy]);
    useEffect(() => {
        dispatch({ type: 'SET_SELECTED_ROW_IDS', payload: { selectedRowIds } });
    }, [selectedRowIds]);
    useEffect(() => {
        var _a;
        if ((tableState === null || tableState === void 0 ? void 0 : tableState.interactiveRowsHavePopIn) && (!(tableState === null || tableState === void 0 ? void 0 : tableState.popInColumns) || ((_a = tableState === null || tableState === void 0 ? void 0 : tableState.popInColumns) === null || _a === void 0 ? void 0 : _a.length) === 0)) {
            dispatch({ type: 'WITH_POPIN', payload: false });
        }
    }, [tableState === null || tableState === void 0 ? void 0 : tableState.interactiveRowsHavePopIn, (_o = tableState === null || tableState === void 0 ? void 0 : tableState.popInColumns) === null || _o === void 0 ? void 0 : _o.length]);
    const tableBodyHeight = useMemo(() => {
        const rowNum = rows.length < internalVisibleRowCount ? Math.max(rows.length, minRows) : internalVisibleRowCount;
        const rowHeight = visibleRowCountMode === TableVisibleRowCountMode.Auto ||
            (tableState === null || tableState === void 0 ? void 0 : tableState.interactiveRowsHavePopIn) ||
            adjustTableHeightOnPopIn
            ? popInRowHeight
            : internalRowHeight;
        return rowHeight * rowNum;
    }, [
        internalRowHeight,
        rows.length,
        internalVisibleRowCount,
        minRows,
        popInRowHeight,
        visibleRowCountMode,
        tableState === null || tableState === void 0 ? void 0 : tableState.interactiveRowsHavePopIn,
        adjustTableHeightOnPopIn
    ]);
    // scroll bar detection
    useEffect(() => {
        const visibleRowCount = rows.length < internalVisibleRowCount ? Math.max(rows.length, minRows) : internalVisibleRowCount;
        if (popInRowHeight !== internalRowHeight) {
            dispatch({
                type: 'TABLE_SCROLLING_ENABLED',
                payload: { isScrollable: visibleRowCount * popInRowHeight > tableBodyHeight || rows.length > visibleRowCount }
            });
        }
        else {
            dispatch({ type: 'TABLE_SCROLLING_ENABLED', payload: { isScrollable: rows.length > visibleRowCount } });
        }
    }, [rows.length, minRows, internalVisibleRowCount, popInRowHeight, tableBodyHeight]);
    const noDataStyles = {
        height: `${tableBodyHeight}px`,
        width: totalColumnsWidth ? `${totalColumnsWidth}px` : '100%'
    };
    const onGroupByChanged = useCallback((e) => {
        const { column, isGrouped } = e.detail;
        let groupedColumns = [];
        if (isGrouped) {
            groupedColumns = [...tableState.groupBy, column.id];
        }
        else {
            groupedColumns = tableState.groupBy.filter((group) => group !== column.id);
        }
        setGroupBy(groupedColumns);
        onGroup(enrichEventWithDetails(e, {
            column,
            groupedColumns
        }));
    }, [tableState.groupBy, onGroup, setGroupBy]);
    useEffect(() => {
        if ((columnOrder === null || columnOrder === void 0 ? void 0 : columnOrder.length) > 0) {
            setColumnOrder(columnOrder);
        }
    }, [columnOrder]);
    const [dragOver, handleDragEnter, handleDragStart, handleDragOver, handleOnDrop, handleOnDragEnd] = useDragAndDrop(onColumnsReorder, isRtl, setColumnOrder, tableState.columnOrder, tableState.columnResizing, tableInternalColumns);
    const inlineStyle = useMemo(() => {
        const tableStyles = {
            maxWidth: '100%',
            overflowX: 'auto',
            display: 'flex',
            flexDirection: 'column'
        };
        if (!!rowHeight) {
            tableStyles['--sapWcrAnalyticalTableRowHeight'] = `${rowHeight}px`;
            tableStyles['--sapWcrAnalyticalTableHeaderRowHeight'] = `${rowHeight}px`;
        }
        if (!!headerRowHeight) {
            tableStyles['--sapWcrAnalyticalTableHeaderRowHeight'] = `${headerRowHeight}px`;
        }
        if (tableState.tableClientWidth > 0) {
            return Object.assign(Object.assign({}, tableStyles), style);
        }
        return Object.assign(Object.assign(Object.assign({}, tableStyles), style), { visibility: 'hidden' });
    }, [tableState.tableClientWidth, style, rowHeight, headerRowHeight]);
    useEffect(() => {
        var _a;
        if (retainColumnWidth && ((_a = tableState.columnResizing) === null || _a === void 0 ? void 0 : _a.isResizingColumn) && tableState.tableColResized == null) {
            dispatch({ type: 'TABLE_COL_RESIZED', payload: true });
        }
        if (tableState.tableColResized && !retainColumnWidth) {
            dispatch({ type: 'TABLE_COL_RESIZED', payload: undefined });
        }
    }, [tableState.columnResizing, retainColumnWidth, tableState.tableColResized]);
    const parentRef = useRef(null);
    const verticalScrollBarRef = useRef(null);
    const handleBodyScroll = (e) => {
        if (typeof onTableScroll === 'function') {
            onTableScroll(e);
        }
        if (verticalScrollBarRef.current && verticalScrollBarRef.current.scrollTop !== parentRef.current.scrollTop) {
            if (!parentRef.current.isExternalVerticalScroll) {
                verticalScrollBarRef.current.scrollTop = parentRef.current.scrollTop;
                verticalScrollBarRef.current.isExternalVerticalScroll = true;
            }
            parentRef.current.isExternalVerticalScroll = false;
        }
    };
    const handleVerticalScrollBarScroll = () => {
        if (!verticalScrollBarRef.current.isExternalVerticalScroll) {
            parentRef.current.scrollTop = verticalScrollBarRef.current.scrollTop;
            parentRef.current.isExternalVerticalScroll = true;
        }
        verticalScrollBarRef.current.isExternalVerticalScroll = false;
    };
    const tableClasses = clsx(classes.table, GlobalStyleClasses.sapScrollBar, withNavigationHighlight && classes.hasNavigationIndicator);
    const columnVirtualizer = useVirtualizer({
        count: visibleColumnsWidth.length,
        getScrollElement: () => tableRef.current,
        estimateSize: useCallback((index) => {
            return visibleColumnsWidth[index];
        }, [visibleColumnsWidth]),
        horizontal: true,
        overscan: overscanCountHorizontal
    });
    scrollToRef.current = Object.assign(Object.assign({}, scrollToRef.current), { horizontalScrollToOffset: columnVirtualizer.scrollToOffset, horizontalScrollToIndex: columnVirtualizer.scrollToIndex });
    return (React.createElement(React.Fragment, null,
        React.createElement("div", Object.assign({ className: className, style: inlineStyle, ref: analyticalTableRef }, rest),
            header && (React.createElement(TitleBar, { ref: titleBarRef, titleBarId: titleBarId }, header)),
            extension && React.createElement("div", { ref: extensionRef }, extension),
            React.createElement(FlexBox, { className: classes.tableContainerWithScrollBar, "data-component-name": "AnalyticalTableContainerWithScrollbar" },
                showOverlay && (React.createElement(React.Fragment, null,
                    React.createElement("span", { id: invalidTableTextId, className: classes.hiddenA11yText, "aria-hidden": true }, invalidTableA11yText),
                    React.createElement("div", { tabIndex: 0, "aria-labelledby": `${titleBarId} ${invalidTableTextId}`, role: "region", "data-component-name": "AnalyticalTableOverlay", className: classes.overlay }))),
                React.createElement("div", Object.assign({ "aria-labelledby": titleBarId }, getTableProps(), { tabIndex: showOverlay ? -1 : 0, role: "grid", "aria-rowcount": rows.length, "aria-colcount": visibleColumns.length, "data-per-page": internalVisibleRowCount, "data-component-name": "AnalyticalTableContainer", ref: tableRef, "data-native-scrollbar": props['data-native-scrollbar'], className: tableClasses }),
                    React.createElement("div", { className: classes.tableHeaderBackgroundElement }),
                    React.createElement("div", { className: classes.tableBodyBackgroundElement }),
                    headerGroups.map((headerGroup) => {
                        let headerProps = {};
                        if (headerGroup.getHeaderGroupProps) {
                            headerProps = headerGroup.getHeaderGroupProps();
                        }
                        return (tableRef.current && (React.createElement(ColumnHeaderContainer, { ref: headerRef, key: headerProps.key, resizeInfo: tableState.columnResizing, headerProps: headerProps, headerGroup: headerGroup, onSort: onSort, onGroupByChanged: onGroupByChanged, onDragStart: handleDragStart, onDragOver: handleDragOver, onDrop: handleOnDrop, onDragEnter: handleDragEnter, onDragEnd: handleOnDragEnd, dragOver: dragOver, isRtl: isRtl, portalContainer: portalContainer, uniqueId: uniqueId, columnVirtualizer: columnVirtualizer, scaleXFactor: scaleXFactor })));
                    }),
                    loading && (rawData === null || rawData === void 0 ? void 0 : rawData.length) > 0 && React.createElement(LoadingComponent, { style: { width: `${totalColumnsWidth}px` } }),
                    loading && (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0 && (React.createElement(TablePlaceholder, { columns: visibleColumns, rows: minRows, style: noDataStyles })),
                    !loading && (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0 && (React.createElement(NoDataComponent, { noDataText: noDataText, className: classes.noDataContainer, style: noDataStyles })),
                    (rawData === null || rawData === void 0 ? void 0 : rawData.length) > 0 && tableRef.current && (React.createElement(VirtualTableBodyContainer, { tableBodyHeight: tableBodyHeight, totalColumnsWidth: totalColumnsWidth, parentRef: parentRef, classes: classes, infiniteScroll: infiniteScroll, infiniteScrollThreshold: infiniteScrollThreshold, onLoadMore: onLoadMore, internalRowHeight: internalRowHeight, popInRowHeight: popInRowHeight, rows: rows, handleExternalScroll: handleBodyScroll, visibleRows: internalVisibleRowCount, dataLength: data === null || data === void 0 ? void 0 : data.length },
                        React.createElement(VirtualTableBody, { classes: classes, prepareRow: prepareRow, rows: rows, minRows: minRows, scrollToRef: scrollToRef, isTreeTable: isTreeTable, internalRowHeight: internalRowHeight, popInRowHeight: popInRowHeight, visibleRows: internalVisibleRowCount, alternateRowColor: alternateRowColor, overscanCount: overscanCount, parentRef: parentRef, visibleColumns: visibleColumns, renderRowSubComponent: renderRowSubComponent, alwaysShowSubComponent: alwaysShowSubComponent, markNavigatedRow: markNavigatedRow, isRtl: isRtl, subComponentsHeight: tableState.subComponentsHeight, dispatch: dispatch, columnVirtualizer: columnVirtualizer })))),
                (tableState.isScrollable === undefined || tableState.isScrollable) && (React.createElement(VerticalScrollbar, { tableBodyHeight: tableBodyHeight, internalRowHeight: internalHeaderRowHeight, popInRowHeight: popInRowHeight, tableRef: tableRef, minRows: minRows, rows: rows, handleVerticalScrollBarScroll: handleVerticalScrollBarScroll, ref: verticalScrollBarRef, "data-native-scrollbar": props['data-native-scrollbar'] }))),
            visibleRowCountMode === TableVisibleRowCountMode.Interactive && (React.createElement(VerticalResizer, { popInRowHeight: popInRowHeight, hasPopInColumns: ((_p = tableState === null || tableState === void 0 ? void 0 : tableState.popInColumns) === null || _p === void 0 ? void 0 : _p.length) > 0, analyticalTableRef: analyticalTableRef, dispatch: dispatch, extensionsHeight: extensionsHeight, internalRowHeight: internalRowHeight, portalContainer: portalContainer }))),
        React.createElement(Text, { "aria-hidden": "true", id: `smartScaleModeHelper-${uniqueId}`, className: classes.hiddenSmartColMeasure }, '')));
});
AnalyticalTable.displayName = 'AnalyticalTable';
AnalyticalTable.defaultProps = {
    infiniteScrollThreshold: 20,
    loading: false,
    sortable: true,
    filterable: false,
    groupable: false,
    selectionMode: TableSelectionMode.None,
    selectionBehavior: TableSelectionBehavior.Row,
    scaleWidthMode: TableScaleWidthMode.Default,
    data: [],
    columns: [],
    minRows: 5,
    groupBy: [],
    NoDataComponent: DefaultNoDataComponent,
    LoadingComponent: DefaultLoadingComponent,
    noDataText: 'No Data',
    reactTableOptions: {},
    tableHooks: [],
    visibleRows: 15,
    subRowsKey: 'subRows',
    highlightField: 'status',
    markNavigatedRow: () => false,
    selectedRowIds: {},
    onGroup: () => { },
    onRowExpandChange: () => { },
    isTreeTable: false,
    alternateRowColor: false,
    overscanCountHorizontal: 5,
    visibleRowCountMode: TableVisibleRowCountMode.Fixed,
    alwaysShowSubComponent: false,
    portalContainer: document.body
};
export { AnalyticalTable };
