import { ThemingParameters, useI18nBundle } from '@ui5/webcomponents-react-base';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import { createUseStyles } from 'react-jss';
import { DRAG_TO_RESIZE } from '../../i18n/i18n-defaults';
const verticalResizerStyles = {
    container: {
        overflow: 'hidden',
        position: 'relative',
        height: '5px',
        textAlign: 'center',
        cursor: 'row-resize',
        boxSizing: 'border-box',
        '&:hover': {
            backgroundColor: ThemingParameters.sapContent_DragAndDropActiveColor,
            color: ThemingParameters.sapHighlightTextColor
        },
        '&:before': {
            fontSize: '10px',
            fontFamily: ThemingParameters.sapFontFamily,
            top: 0,
            position: 'absolute',
            content: '"\u2981\u2981\u2981\u2981"',
            lineHeight: '5px',
            pointerEvents: 'none'
        }
    },
    resizer: {
        position: 'absolute',
        opacity: 0.5,
        backgroundColor: ThemingParameters.sapContent_DragAndDropActiveColor,
        height: '5px'
    }
};
const useStyles = createUseStyles(verticalResizerStyles, { name: 'VerticalResizer' });
const isTouchEvent = (e, touchEvent) => {
    if (e.type === touchEvent) {
        return !(e.touches && e.touches.length > 1);
    }
    return false;
};
export const VerticalResizer = (props) => {
    var _a, _b, _c;
    const { analyticalTableRef, dispatch, extensionsHeight, internalRowHeight, hasPopInColumns, popInRowHeight, portalContainer } = props;
    const classes = useStyles();
    const startY = useRef(null);
    const verticalResizerRef = useRef(null);
    const [resizerPosition, setResizerPosition] = useState(undefined);
    const [isDragging, setIsDragging] = useState(false);
    const [mountTouchEvents, setMountTouchEvents] = useState(false);
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    const handleResizeStart = useCallback((e) => {
        e.preventDefault();
        const touchEvent = isTouchEvent(e, 'touchstart');
        startY.current = touchEvent ? Math.round(e.touches[0].pageY) : e.pageY;
        setMountTouchEvents(touchEvent);
        setIsDragging(true);
    }, [startY.current, setIsDragging]);
    const handleMove = useCallback((e) => {
        setResizerPosition((prev) => (Object.assign(Object.assign({}, prev), { top: isTouchEvent(e, 'touchmove') ? Math.round(e.touches[0].pageY) : e.pageY })));
    }, [setResizerPosition]);
    const handleResizeEnd = useCallback((e) => {
        setIsDragging(false);
        const rowCount = Math.floor((analyticalTableRef.current.clientHeight +
            (isTouchEvent(e, 'touchend') ? Math.round(e.changedTouches[0].pageY) : e.pageY) -
            startY.current -
            extensionsHeight -
            5) /*resizer height*/ /
            popInRowHeight);
        if (hasPopInColumns) {
            dispatch({ type: 'INTERACTIVE_ROWS_HAVE_POPIN', payload: true });
        }
        dispatch({
            type: 'VISIBLE_ROWS',
            payload: { visibleRows: rowCount }
        });
    }, [(_a = analyticalTableRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight, startY.current, extensionsHeight, internalRowHeight, dispatch]);
    useEffect(() => {
        const removeEventListeners = () => {
            if (mountTouchEvents) {
                document.removeEventListener('touchmove', handleMove);
                document.removeEventListener('touchend', handleResizeEnd);
            }
            else {
                document.removeEventListener('mouseup', handleResizeEnd);
                document.removeEventListener('mousemove', handleMove);
            }
        };
        if (isDragging) {
            if (mountTouchEvents) {
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('touchend', handleResizeEnd);
            }
            else {
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleResizeEnd);
            }
        }
        else {
            removeEventListeners();
        }
        return () => {
            removeEventListeners();
        };
    }, [isDragging]);
    useEffect(() => {
        var _a, _b, _c, _d, _e, _f;
        const resizerPosTop = ((_b = (_a = verticalResizerRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.top) + window.scrollY;
        const resizerPosLeft = ((_d = (_c = verticalResizerRef.current) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect()) === null || _d === void 0 ? void 0 : _d.left) + window.scrollX;
        const resizerPosWidth = (_f = (_e = verticalResizerRef.current) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect()) === null || _f === void 0 ? void 0 : _f.width;
        if (!isDragging && resizerPosTop > 0) {
            setResizerPosition({ left: resizerPosLeft, top: resizerPosTop, width: resizerPosWidth });
        }
    }, [(_c = (_b = verticalResizerRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c.top, isDragging]);
    useEffect(() => {
        return () => {
            dispatch({ type: 'WITH_POPIN', payload: false });
        };
    }, []);
    return (React.createElement("div", { className: classes.container, ref: verticalResizerRef, onMouseDown: handleResizeStart, onTouchStart: handleResizeStart, role: "separator", title: i18nBundle.getText(DRAG_TO_RESIZE) }, resizerPosition &&
        isDragging &&
        createPortal(React.createElement("div", { className: classes.resizer, style: { top: resizerPosition.top, left: resizerPosition.left, width: resizerPosition.width } }), portalContainer)));
};
