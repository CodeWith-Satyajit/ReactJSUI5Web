import { useCallback, useEffect, useRef, useState } from 'react';
export const useObserveHeights = (pageRef, topHeaderRef, headerContentRef, anchorBarRef, [headerCollapsed, setHeaderCollapsed], { noHeader, fixedHeader = false }) => {
    var _a, _b;
    const [topHeaderHeight, setTopHeaderHeight] = useState(0);
    const [headerContentHeight, setHeaderContentHeight] = useState(0);
    const [isIntersecting, setIsIntersecting] = useState(true);
    const prevScrollTop = useRef(0);
    const onScroll = useCallback((e) => {
        const scrollDown = prevScrollTop.current <= e.target.scrollTop;
        prevScrollTop.current = e.target.scrollTop;
        if (scrollDown && e.target.scrollTop >= headerContentHeight && !headerCollapsed) {
            setIsIntersecting(false);
            setHeaderCollapsed(true);
        }
        else if (!scrollDown && e.target.scrollTop <= topHeaderHeight && headerCollapsed) {
            setIsIntersecting(true);
            setHeaderCollapsed(false);
        }
    }, [headerContentHeight, topHeaderHeight, headerCollapsed]);
    useEffect(() => {
        if (!fixedHeader) {
            pageRef.current.addEventListener('scroll', onScroll);
        }
        return () => {
            var _a;
            (_a = pageRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', onScroll);
        };
    }, [onScroll, fixedHeader]);
    // top header
    useEffect(() => {
        const headerContentResizeObserver = new ResizeObserver(([header]) => {
            var _a;
            // Firefox implements `borderBoxSize` as a single content rect, rather than an array
            const borderBoxSize = Array.isArray(header.borderBoxSize) ? header.borderBoxSize[0] : header.borderBoxSize;
            // Safari doesn't implement `borderBoxSize`
            setTopHeaderHeight((_a = borderBoxSize === null || borderBoxSize === void 0 ? void 0 : borderBoxSize.blockSize) !== null && _a !== void 0 ? _a : header.target.getBoundingClientRect().height);
        });
        if (topHeaderRef === null || topHeaderRef === void 0 ? void 0 : topHeaderRef.current) {
            headerContentResizeObserver.observe(topHeaderRef.current);
        }
        return () => {
            headerContentResizeObserver.disconnect();
        };
    }, []);
    // header content
    useEffect(() => {
        const headerContentResizeObserver = new ResizeObserver(([headerContent]) => {
            var _a;
            if (isIntersecting) {
                // Firefox implements `borderBoxSize` as a single content rect, rather than an array
                const borderBoxSize = Array.isArray(headerContent.borderBoxSize)
                    ? headerContent.borderBoxSize[0]
                    : headerContent.borderBoxSize;
                // Safari doesn't implement `borderBoxSize`
                setHeaderContentHeight((_a = borderBoxSize === null || borderBoxSize === void 0 ? void 0 : borderBoxSize.blockSize) !== null && _a !== void 0 ? _a : headerContent.target.getBoundingClientRect().height);
            }
        });
        if (headerContentRef === null || headerContentRef === void 0 ? void 0 : headerContentRef.current) {
            headerContentResizeObserver.observe(headerContentRef.current);
        }
        return () => {
            headerContentResizeObserver.disconnect();
        };
    }, [isIntersecting]);
    const anchorBarHeight = (_b = (_a = anchorBarRef === null || anchorBarRef === void 0 ? void 0 : anchorBarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 33;
    const totalHeaderHeight = (noHeader ? 0 : topHeaderHeight + headerContentHeight) + anchorBarHeight;
    return { topHeaderHeight, headerContentHeight, anchorBarHeight, totalHeaderHeight, headerCollapsed };
};
