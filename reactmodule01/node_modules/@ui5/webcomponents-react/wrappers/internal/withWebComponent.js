var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { getEffectiveScopingSuffixForTag } from '@ui5/webcomponents-base/dist/CustomElementsScope.js';
import { useIsomorphicLayoutEffect, useSyncRef } from '@ui5/webcomponents-react-base';
import React, { Children, cloneElement, forwardRef, useEffect, useState } from 'react';
const capitalizeFirstLetter = (s) => s.charAt(0).toUpperCase() + s.slice(1);
const camelToKebabCase = (s) => s.replace(/([A-Z])/g, (a, b) => `-${b.toLowerCase()}`);
const kebabToCamelCase = (str) => str.replace(/([-_]\w)/g, (g) => g[1].toUpperCase());
const createEventPropName = (eventName) => `on${capitalizeFirstLetter(kebabToCamelCase(eventName))}`;
const definedWebComponents = new Set([]);
export const withWebComponent = (tagName, regularProperties, booleanProperties, slotProperties, eventProperties) => {
    // displayName will be assigned in the individual files
    // eslint-disable-next-line react/display-name
    return forwardRef((props, wcRef) => {
        const { className, children, waitForDefine } = props, rest = __rest(props, ["className", "children", "waitForDefine"]);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const [componentRef, ref] = useSyncRef(wcRef);
        const tagNameSuffix = getEffectiveScopingSuffixForTag(tagName);
        const Component = (tagNameSuffix ? `${tagName}-${tagNameSuffix}` : tagName);
        const [isDefined, setIsDefined] = useState(definedWebComponents.has(Component));
        // regular props (no booleans, no slots and no events)
        const regularProps = regularProperties.reduce((acc, name) => {
            if (rest.hasOwnProperty(name)) {
                return Object.assign(Object.assign({}, acc), { [camelToKebabCase(name)]: rest[name] });
            }
            return acc;
        }, {});
        // boolean properties - only attach if they are truthy
        const booleanProps = booleanProperties.reduce((acc, name) => {
            if (rest[name] === true || rest[name] === 'true') {
                return Object.assign(Object.assign({}, acc), { [camelToKebabCase(name)]: true });
            }
            return acc;
        }, {});
        const slots = slotProperties.reduce((acc, name) => {
            const slotValue = rest[name];
            if (!slotValue)
                return acc;
            const slottedChildren = [];
            let index = 0;
            const removeFragments = (element) => {
                var _a;
                if (!element)
                    return;
                if (element.type === React.Fragment) {
                    Children.toArray((_a = element.props) === null || _a === void 0 ? void 0 : _a.children)
                        .filter(Boolean)
                        .forEach((item) => {
                        removeFragments(item);
                    });
                }
                else {
                    slottedChildren.push(cloneElement(element, {
                        key: `${name}-${index}`,
                        slot: name
                    }));
                    index++;
                }
            };
            if (Array.isArray(slotValue)) {
                slotValue.forEach((item) => {
                    removeFragments(item);
                });
            }
            else {
                removeFragments(slotValue);
            }
            return [...acc, ...slottedChildren];
        }, []);
        // event binding
        useIsomorphicLayoutEffect(() => {
            const localRef = ref.current;
            const eventRegistry = {};
            if (!waitForDefine || isDefined) {
                eventProperties.forEach((eventName) => {
                    const eventHandler = rest[createEventPropName(eventName)];
                    if (typeof eventHandler === 'function') {
                        eventRegistry[eventName] = eventHandler;
                        localRef === null || localRef === void 0 ? void 0 : localRef.addEventListener(eventName, eventRegistry[eventName]);
                    }
                });
                return () => {
                    // eslint-disable-next-line guard-for-in
                    for (const eventName in eventRegistry) {
                        localRef === null || localRef === void 0 ? void 0 : localRef.removeEventListener(eventName, eventRegistry[eventName]);
                    }
                };
            }
        }, [...eventProperties.map((eventName) => rest[createEventPropName(eventName)]), isDefined, waitForDefine]);
        // non web component related props, just pass them
        const nonWebComponentRelatedProps = Object.entries(rest)
            .filter(([key]) => !regularProperties.includes(key))
            .filter(([key]) => !slotProperties.includes(key))
            .filter(([key]) => !booleanProperties.includes(key))
            .filter(([key]) => !eventProperties.map((eventName) => createEventPropName(eventName)).includes(key))
            .reduce((acc, [key, val]) => (Object.assign(Object.assign({}, acc), { [key]: val })), {});
        useEffect(() => {
            if (waitForDefine && !isDefined) {
                customElements.whenDefined(Component).then(() => {
                    setIsDefined(true);
                    definedWebComponents.add(Component);
                });
            }
        }, [Component, waitForDefine, isDefined]);
        if (waitForDefine && !isDefined) {
            return null;
        }
        return (React.createElement(Component, Object.assign({ ref: componentRef }, booleanProps, regularProps, nonWebComponentRelatedProps, { class: className }),
            slots,
            children));
    });
};
