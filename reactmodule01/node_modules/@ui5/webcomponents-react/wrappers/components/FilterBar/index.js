var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { debounce, Device, enrichEventWithDetails, useI18nBundle } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { Children, cloneElement, forwardRef, useEffect, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { ButtonDesign, ToolbarStyle } from '../../enums';
import { ADAPT_FILTERS, CLEAR, FILTERS, GO, HIDE_FILTER_BAR, RESTORE, SHOW_FILTER_BAR } from '../../i18n/i18n-defaults';
import { Button } from '../../webComponents';
import { Toolbar } from '../Toolbar';
import { ToolbarSeparator } from '../ToolbarSeparator';
import { ToolbarSpacer } from '../ToolbarSpacer';
import styles from './FilterBar.jss';
import { FilterDialog } from './FilterDialog';
import { filterValue, renderSearchWithValue, syncRef } from './utils';
const isPhone = Device.isPhone();
const isTablet = Device.isTablet();
const resizeObserverEntryWidth = (entry) => {
    var _a, _b;
    if (entry.borderBoxSize) {
        // Firefox implements `borderBoxSize` as a single content rect, rather than an array
        return Array.isArray(entry.borderBoxSize) ? (_a = entry.borderBoxSize[0]) === null || _a === void 0 ? void 0 : _a.inlineSize : (_b = entry.borderBoxSize) === null || _b === void 0 ? void 0 : _b.inlineSize;
    }
    // Safari doesn't implement `borderBoxSize`
    return entry.target.getBoundingClientRect().width;
};
const useStyles = createUseStyles(styles, { name: 'FilterBar' });
/**
 * The `FilterBar` displays filters in a user-friendly manner to populate values for a query. It consists of a row containing the `VariantManagement` or a title, the related buttons, and an area underneath displaying the filters. The filters are arranged in a logical row that is divided depending on the space available and the width of the filters. The area containing the filters can be hidden or shown using the "Hide FilterBar / Show FilterBar" button, the "Filters" button shows the filter dialog.
 In this dialog, the consumer has full control over the FilterBar. The filters in this dialog are displayed in one column and organized in groups. Each filter can be marked as visible in the FilterBar by selecting "Add to FilterBar".
 */
const FilterBar = forwardRef((props, ref) => {
    var _a, _b;
    const { children, hideToolbar, filterBarCollapsed, considerGroupName, filterContainerWidth, activeFiltersCount, showClearOnFB, showGoOnFB, hideFilterConfiguration, showRestoreOnFB, showResetButton, hideToggleFiltersButton, style, className, slot, search, header, as, portalContainer, onToggleFilters, onFiltersDialogOpen, onAfterFiltersDialogOpen, onFiltersDialogCancel, onFiltersDialogClose, onFiltersDialogSave, onClear, onFiltersDialogSelectionChange, onFiltersDialogSearch, onGo, onRestore } = props, rest = __rest(props, ["children", "hideToolbar", "filterBarCollapsed", "considerGroupName", "filterContainerWidth", "activeFiltersCount", "showClearOnFB", "showGoOnFB", "hideFilterConfiguration", "showRestoreOnFB", "showResetButton", "hideToggleFiltersButton", "style", "className", "slot", "search", "header", "as", "portalContainer", "onToggleFilters", "onFiltersDialogOpen", "onAfterFiltersDialogOpen", "onFiltersDialogCancel", "onFiltersDialogClose", "onFiltersDialogSave", "onClear", "onFiltersDialogSelectionChange", "onFiltersDialogSearch", "onGo", "onRestore"]);
    const initiallyShowFilters = (() => {
        if (!hideToolbar) {
            if (filterBarCollapsed !== undefined) {
                return filterBarCollapsed;
            }
            return !isTablet;
        }
        return true;
    })();
    const [showFilters, setShowFilters] = useState(initiallyShowFilters);
    const [mountFilters, setMountFilters] = useState(true);
    const [dialogOpen, setDialogOpen] = useState(false);
    const [searchValue, setSearchValue] = useState(undefined);
    const searchRef = useRef(null);
    const filterRefs = useRef({});
    const dialogRef = useRef(null);
    const [dialogRefs, setDialogRefs] = useState({});
    const [toggledFilters, setToggledFilters] = useState({});
    const prevVisibleInFilterBarProps = useRef({});
    const prevSearchInputPropsValueRef = useRef();
    const filterBarButtonsRef = useRef(null);
    const filterAreaRef = useRef(null);
    const filterBtnRef = useRef(null);
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    const clearText = i18nBundle.getText(CLEAR);
    const restoreText = i18nBundle.getText(RESTORE);
    const showFilterBarText = i18nBundle.getText(SHOW_FILTER_BAR);
    const hideFilterBarText = i18nBundle.getText(HIDE_FILTER_BAR);
    const goText = i18nBundle.getText(GO);
    const filtersText = !hideToolbar ? i18nBundle.getText(FILTERS) : i18nBundle.getText(ADAPT_FILTERS);
    // dialog
    const [isListView, setIsListView] = useState(true);
    const [filteredAttribute, setFilteredAttribute] = useState('all');
    useEffect(() => {
        Children.toArray(children).forEach((item) => {
            setToggledFilters((prev) => {
                if (!item.props.hasOwnProperty('visibleInFilterBar') && (prev === null || prev === void 0 ? void 0 : prev[item.key]) === undefined) {
                    return Object.assign(Object.assign({}, prev), { [item.key]: true });
                }
                if (item.props.hasOwnProperty('visibleInFilterBar')) {
                    return Object.assign(Object.assign({}, prev), { [item.key]: item.props.visibleInFilterBar });
                }
                return prev;
            });
        });
    }, [children, setToggledFilters]);
    useEffect(() => {
        if (filterBarCollapsed !== undefined) {
            setShowFilters(!hideToolbar ? !filterBarCollapsed : true);
        }
    }, [setShowFilters, hideToolbar, filterBarCollapsed]);
    const classes = useStyles();
    const filterAreaClasses = clsx(classes.filterArea, showFilters && (!isPhone || (isPhone && hideToolbar)) ? classes.filterAreaOpen : classes.filterAreaClosed);
    const getFilterElements = () => {
        var _a;
        const search = (_a = searchRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-component-name="FilterBarSearch"]`);
        return {
            filters: (filterRefs === null || filterRefs === void 0 ? void 0 : filterRefs.current) ? Object.values(filterRefs.current).filter(Boolean) : [],
            search
        };
    };
    const handleToggle = (e) => {
        if (onToggleFilters) {
            onToggleFilters(enrichEventWithDetails(e, Object.assign({ visible: !showFilters }, getFilterElements())));
        }
        setShowFilters(!showFilters);
    };
    const [executeGo, setExecuteGo] = useState(false);
    const handleDialogSave = (e, newRefs, updatedToggledFilters) => {
        setDialogRefs(newRefs);
        const details = Object.assign({ elements: newRefs, toggledElements: Object.assign(Object.assign({}, toggledFilters), updatedToggledFilters) }, getFilterElements());
        setToggledFilters((old) => (Object.assign(Object.assign({}, old), updatedToggledFilters)));
        if (onFiltersDialogSave) {
            onFiltersDialogSave(enrichEventWithDetails(e, details));
        }
        handleDialogClose(e);
    };
    const handleDialogOpen = (e) => {
        if (typeof onFiltersDialogOpen === 'function') {
            onFiltersDialogOpen(e);
        }
        if (e.defaultPrevented) {
            setDialogOpen(false);
        }
        else {
            setDialogOpen(true);
        }
    };
    const handleDialogClose = (e) => {
        var _a;
        if (onFiltersDialogClose) {
            onFiltersDialogClose(enrichEventWithDetails(e));
        }
        setDialogOpen(false);
        (_a = filterBtnRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const handleGoOnFb = (e) => {
        if (typeof onGo === 'function') {
            onGo(enrichEventWithDetails(e, Object.assign({ elements: filterRefs.current }, getFilterElements())));
        }
    };
    const safeChildren = () => {
        if (Object.keys(toggledFilters).length > 0) {
            return Children.toArray(children).map((child) => {
                if ((toggledFilters === null || toggledFilters === void 0 ? void 0 : toggledFilters[child.key]) !== undefined) {
                    return cloneElement(child, {
                        visibleInFilterBar: toggledFilters[child.key]
                    });
                }
                return child;
            });
        }
        return Children.toArray(children);
    };
    const prevChildren = useRef({});
    const renderChildren = () => {
        const childProps = { considerGroupName, ['data-in-fb']: true, ['data-with-toolbar']: !hideToolbar };
        return safeChildren()
            .filter((item) => {
            var _a, _b;
            return ((_a = item === null || item === void 0 ? void 0 : item.props) === null || _a === void 0 ? void 0 : _a.visible) && ((_b = item.props) === null || _b === void 0 ? void 0 : _b.visibleInFilterBar);
        })
            .map((child) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            // necessary because of varying widths of input elements
            if (filterContainerWidth) {
                childProps.style = Object.assign({ width: filterContainerWidth }, child.props.style);
            }
            if (hideFilterConfiguration) {
                return cloneElement(child, Object.assign({}, childProps));
            }
            prevVisibleInFilterBarProps.current[child.key] = child.props.visibleInFilterBar;
            let filterItemProps = {};
            if (Object.keys(dialogRefs).length > 0) {
                const dialogItemRef = dialogRefs[child.key];
                if (dialogItemRef) {
                    filterItemProps = filterValue(dialogItemRef, child);
                }
            }
            if (!child.props.children) {
                return cloneElement(child, Object.assign({}, childProps));
            }
            if (((_a = prevChildren.current) === null || _a === void 0 ? void 0 : _a[child.key]) &&
                //Input
                (((_c = (_b = child.props.children) === null || _b === void 0 ? void 0 : _b.props) === null || _c === void 0 ? void 0 : _c.value) !== ((_e = (_d = prevChildren.current) === null || _d === void 0 ? void 0 : _d[child.key]) === null || _e === void 0 ? void 0 : _e.value) ||
                    //Checkbox
                    ((_g = (_f = child.props.children) === null || _f === void 0 ? void 0 : _f.props) === null || _g === void 0 ? void 0 : _g.checked) !== ((_j = (_h = prevChildren.current) === null || _h === void 0 ? void 0 : _h[child.key]) === null || _j === void 0 ? void 0 : _j.checked) ||
                    //Selectable
                    (Array.isArray((_l = (_k = child.props.children) === null || _k === void 0 ? void 0 : _k.props) === null || _l === void 0 ? void 0 : _l.children) &&
                        ((_p = (_o = (_m = child.props.children) === null || _m === void 0 ? void 0 : _m.props) === null || _o === void 0 ? void 0 : _o.children) === null || _p === void 0 ? void 0 : _p.map((item) => item.props.selected).join(',')) !==
                            ((_s = (_r = (_q = prevChildren === null || prevChildren === void 0 ? void 0 : prevChildren.current) === null || _q === void 0 ? void 0 : _q[child.key]) === null || _r === void 0 ? void 0 : _r.children) === null || _s === void 0 ? void 0 : _s.map((item) => item.props.selected).join(','))))) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                const _t = dialogRefs, _u = child.key, _omit = _t[_u], rest = __rest(_t, [typeof _u === "symbol" ? _u : _u + ""]);
                setDialogRefs(rest);
            }
            prevChildren.current[child.key] = child.props.children.props;
            return cloneElement(child, Object.assign(Object.assign({}, childProps), { children: Object.assign(Object.assign({}, child.props.children), { props: Object.assign(Object.assign({}, child.props.children.props), filterItemProps), ref: (node) => {
                        filterRefs.current[child.key] = node;
                        if (!dialogOpen)
                            syncRef(child.props.children.ref, node);
                    } }) }));
        });
    };
    const handleRestoreFilters = (e, source, filterElements) => {
        if (source === 'filterBar' && showGoOnFB) {
            setMountFilters(false);
        }
        if (onRestore) {
            onRestore(enrichEventWithDetails(e, Object.assign({ source }, filterElements)));
        }
    };
    useEffect(() => {
        if (!mountFilters) {
            setMountFilters(true);
        }
    }, [mountFilters]);
    const handleFBRestore = (e) => {
        handleRestoreFilters(e, 'filterBar', getFilterElements());
    };
    const handleClear = (e) => {
        if (typeof onClear === 'function') {
            onClear(enrichEventWithDetails(e, getFilterElements()));
        }
    };
    const cssClasses = clsx(classes.outerContainer, className, !hideToolbar && classes.outerContainerWithToolbar);
    useEffect(() => {
        var _a;
        prevSearchInputPropsValueRef.current = (_a = search === null || search === void 0 ? void 0 : search.props) === null || _a === void 0 ? void 0 : _a.value;
    }, [(_a = search === null || search === void 0 ? void 0 : search.props) === null || _a === void 0 ? void 0 : _a.value]);
    const prevSearchInputPropsValue = prevSearchInputPropsValueRef.current;
    useEffect(() => {
        var _a, _b;
        if (prevSearchInputPropsValue !== ((_a = search === null || search === void 0 ? void 0 : search.props) === null || _a === void 0 ? void 0 : _a.value)) {
            setSearchValue((_b = search === null || search === void 0 ? void 0 : search.props) === null || _b === void 0 ? void 0 : _b.value);
        }
    }, [prevSearchInputPropsValue, (_b = search === null || search === void 0 ? void 0 : search.props) === null || _b === void 0 ? void 0 : _b.value]);
    const ToolbarButtons = (React.createElement(React.Fragment, null,
        showGoOnFB && (React.createElement(Button, { onClick: handleGoOnFb, design: ButtonDesign.Emphasized }, goText)),
        !hideToggleFiltersButton && !hideToolbar && !isPhone && (React.createElement(Button, { onClick: handleToggle, design: ButtonDesign.Transparent, className: classes.showFiltersBtn, "aria-live": "polite" }, showFilters ? hideFilterBarText : showFilterBarText)),
        showClearOnFB && (React.createElement(Button, { onClick: handleClear, design: ButtonDesign.Transparent }, clearText)),
        showRestoreOnFB && (React.createElement(Button, { onClick: handleFBRestore, design: ButtonDesign.Transparent }, restoreText)),
        !hideFilterConfiguration && (React.createElement(Button, { onClick: handleDialogOpen, "aria-haspopup": "dialog", design: ButtonDesign.Transparent, ref: filterBtnRef }, `${filtersText}${activeFiltersCount && parseInt(activeFiltersCount, 10) > 0 ? ` (${activeFiltersCount})` : ''}`))));
    const hasButtons = ToolbarButtons.props.children.some(Boolean);
    const [filterBarButtonsWidth, setFilterBarButtonsWidth] = useState(undefined);
    const [filterAreaWidth, setFilterAreaWidth] = useState(undefined);
    const [firstChildWidth, setFirstChildWidth] = useState(undefined);
    useEffect(() => {
        const debouncedObserverFn = debounce(([area]) => {
            var _a, _b;
            const firstChild = (_b = (_a = area.target) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b[0];
            if (firstChild && firstChild.offsetWidth !== firstChildWidth) {
                setFirstChildWidth(firstChild.offsetWidth + 16 /*margin*/);
            }
        }, 100);
        const filterAreaObserver = new ResizeObserver(debouncedObserverFn);
        if (hideToolbar && filterAreaRef.current) {
            filterAreaObserver.observe(filterAreaRef.current);
        }
        return () => {
            debouncedObserverFn.cancel();
            filterAreaObserver.disconnect();
        };
    }, [filterAreaRef.current, hideToolbar]);
    useEffect(() => {
        const debouncedObserverFn = debounce(([area]) => {
            const filterWidth = resizeObserverEntryWidth(area);
            if (filterWidth !== filterBarButtonsWidth) {
                setFilterAreaWidth(filterWidth);
            }
        }, 100);
        const filterAreaObserver = new ResizeObserver(debouncedObserverFn);
        if (hideToolbar && filterAreaRef.current) {
            filterAreaObserver.observe(filterAreaRef.current);
        }
        return () => {
            debouncedObserverFn.cancel();
            filterAreaObserver.disconnect();
        };
    }, [filterAreaWidth, filterAreaRef.current, hideToolbar]);
    useEffect(() => {
        const debouncedObserverFn = debounce(([buttons]) => {
            const buttonsWidth = resizeObserverEntryWidth(buttons);
            if (buttonsWidth !== filterBarButtonsWidth) {
                setFilterBarButtonsWidth(buttonsWidth);
            }
        }, 100);
        const filterBarButtonsObserver = new ResizeObserver(debouncedObserverFn);
        if (hideToolbar && filterBarButtonsRef.current) {
            filterBarButtonsObserver.observe(filterBarButtonsRef.current);
        }
        return () => {
            debouncedObserverFn.cancel();
            filterBarButtonsObserver.disconnect();
        };
    }, [filterBarButtonsRef.current, hideToolbar, filterBarButtonsWidth]);
    const calculatedChildren = renderChildren();
    useEffect(() => {
        if (executeGo) {
            setExecuteGo((prevEvent) => {
                onGo(prevEvent);
                return false;
            });
        }
    }, [executeGo]);
    // calculates the number of spacers depending on the available width inside the row
    const renderSpacers = () => {
        if (firstChildWidth && filterAreaWidth && filterBarButtonsWidth) {
            const spacers = [];
            const filterItemsWidth = calculatedChildren.length * firstChildWidth;
            //early return if enough space is available
            if (filterAreaWidth - filterBarButtonsWidth > filterItemsWidth) {
                return null;
            }
            const usedSpaceLastRow = filterItemsWidth % filterAreaWidth;
            const emptySpaceLastRow = filterAreaWidth - usedSpaceLastRow;
            // deduct width of buttons container of the empty space in the last row to calculate number of spacers
            const numberOfSpacers = Math.floor((emptySpaceLastRow - filterBarButtonsWidth) / firstChildWidth);
            for (let i = 0; i < numberOfSpacers; i++) {
                spacers.push(React.createElement("div", { key: `filter-spacer-${i}`, className: classes.spacer }));
            }
            return spacers;
        }
        return null;
    };
    const CustomTag = as;
    return (React.createElement(React.Fragment, null,
        dialogOpen && !hideFilterConfiguration && (React.createElement(FilterDialog, { filterBarRefs: filterRefs, open: dialogOpen, handleDialogClose: handleDialogClose, handleRestoreFilters: handleRestoreFilters, handleSearchValueChange: setSearchValue, showRestoreButton: showResetButton, handleSelectionChange: onFiltersDialogSelectionChange, handleDialogSave: handleDialogSave, handleDialogSearch: onFiltersDialogSearch, handleDialogCancel: onFiltersDialogCancel, onAfterFiltersDialogOpen: onAfterFiltersDialogOpen, portalContainer: portalContainer, dialogRef: dialogRef, isListView: isListView, setIsListView: setIsListView, filteredAttribute: filteredAttribute, setFilteredAttribute: setFilteredAttribute }, safeChildren())),
        React.createElement(CustomTag, Object.assign({ ref: ref, className: cssClasses, style: Object.assign({ ['--_ui5wcr_filter_group_item_flex_basis']: filterContainerWidth }, style), slot: slot }, rest),
            !hideToolbar && (React.createElement(Toolbar, { className: classes.filterBarHeader, toolbarStyle: ToolbarStyle.Clear },
                header,
                header && search && React.createElement(ToolbarSeparator, null),
                search && !isPhone && React.createElement("div", { ref: searchRef }, renderSearchWithValue(search, searchValue)),
                hasButtons && React.createElement(ToolbarSpacer, null),
                ToolbarButtons)),
            mountFilters && (React.createElement("div", { className: filterAreaClasses, style: { position: 'relative' }, ref: filterAreaRef },
                calculatedChildren,
                hideToolbar && (React.createElement(React.Fragment, null,
                    renderSpacers(),
                    React.createElement("div", { style: {
                            width: filterBarButtonsWidth ? `${filterBarButtonsWidth}px` : '120px',
                            minWidth: filterBarButtonsWidth ? `${filterBarButtonsWidth}px` : '120px'
                        }, className: classes.lastSpacer },
                        React.createElement("div", { className: classes.filterBarButtons, ref: filterBarButtonsRef }, ToolbarButtons)))))))));
});
FilterBar.defaultProps = {
    as: 'div',
    filterContainerWidth: '13.125rem',
    portalContainer: document.body
};
FilterBar.displayName = 'FilterBar';
export { FilterBar };
