var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Device, useIsomorphicLayoutEffect, useSyncRef } from '@ui5/webcomponents-react-base';
import clsx from 'clsx';
import React, { forwardRef, useContext, useEffect, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { SplitterLayoutContext } from '../../internal/SplitterLayoutContext';
const useStyles = createUseStyles({
    splitterElement: {
        display: 'flex',
        overflow: 'hidden',
        position: 'relative',
        willChange: 'flex-basis',
        minWidth: '0px',
        minHeight: '0px'
    }
}, { name: 'SplitterElement' });
/**
 * The `SplitterElement` holds the component of the content area. Allowed size values are of the type css property width or
 * height according to the orientation of the `SplitterLayout`. If `size` isn't passed to the element, the width or
 * height of the content area will be calculated automatically according to the size of the given `SplitterLayout`.
 * The `minSize` defines the minimum width or height of the area and is set to 0 when no minimum size is given, so the
 * content can be completely collapsed.
 */
const SplitterElement = forwardRef((props, ref) => {
    const { children, style, className, minSize, size, resizable: _0 } = props, rest = __rest(props, ["children", "style", "className", "minSize", "size", "resizable"]);
    const [componentRef, splitterElementRef] = useSyncRef(ref);
    const { vertical, reset } = useContext(SplitterLayoutContext);
    const safariStyles = Device.isSafari() ? { width: 'min-content', flex: '1 0 auto' } : {};
    const [flexStyles, setFlexStyles] = useState(size !== 'auto' ? { flex: `0 0 ${size}` } : Object.assign({ flex: '1 0 min-content' }, safariStyles));
    const [flexBasisApplied, setFlexBasisApplied] = useState(false);
    const classes = useStyles();
    useEffect(() => {
        const elementObserver = new ResizeObserver(([element]) => {
            if (element.target.getBoundingClientRect().width !== 0 && !flexBasisApplied) {
                const resetSafariStyles = Device.isSafari() ? { width: 'unset' } : {};
                setFlexStyles(Object.assign({ flex: `0 0 ${element.target.getBoundingClientRect().width}px` }, resetSafariStyles));
                setFlexBasisApplied(true);
            }
        });
        if (size === 'auto' && splitterElementRef.current) {
            elementObserver.observe(splitterElementRef.current);
        }
        else {
            setFlexStyles({ flex: `0 0 ${size}` });
        }
        return () => {
            elementObserver.disconnect();
        };
    }, [size, flexBasisApplied]);
    useIsomorphicLayoutEffect(() => {
        if (reset) {
            setFlexStyles(size !== 'auto' ? { flex: `0 0 ${size}` } : Object.assign({ flex: '1 0 min-content' }, safariStyles));
            setFlexBasisApplied(false);
        }
    }, [reset, size]);
    return (React.createElement("div", Object.assign({ ref: componentRef, className: clsx(classes.splitterElement, classes[vertical ? 'vertical' : 'horizontal'], className), style: Object.assign(Object.assign({ minHeight: vertical && minSize ? `${minSize}px` : undefined, minWidth: !vertical && minSize ? `${minSize}px` : undefined }, flexStyles), style) }, rest, { "data-min-size": minSize }), children));
});
SplitterElement.defaultProps = {
    minSize: 0,
    size: 'auto'
};
SplitterElement.displayName = 'SplitterElement';
export { SplitterElement };
