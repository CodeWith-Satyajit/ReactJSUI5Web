import { useEffect } from 'react';
import { TableSelectionBehavior, TableSelectionMode } from '../../../enums';
const getParentIndicesRecursive = (rowId) => {
    const parentIndices = {};
    const getParentIndices = (internalRowId) => {
        const lastDotIndex = internalRowId.lastIndexOf('.');
        if (~lastDotIndex) {
            const parentRowId = internalRowId.slice(0, lastDotIndex);
            if (!parentIndices[parentRowId]) {
                parentIndices[parentRowId] = true;
                getParentIndices(parentRowId);
            }
        }
    };
    getParentIndices(rowId);
    return parentIndices;
};
/**
 * A plugin hook that marks parent rows as indeterminate if a child row is selected in `MultiSelect` mode.
 * When using this hook, it is recommended to also select all sub-rows when selecting a row. (`reactTableOptions={{ selectSubRows: true }}`)
 */
export const useIndeterminateRowSelection = () => {
    const toggleRowProps = (rowProps, { row, instance }) => {
        var _a, _b, _c;
        let indeterminate;
        if (instance.isAllRowsSelected) {
            indeterminate = false;
        }
        else {
            indeterminate = (_c = (_b = (_a = instance === null || instance === void 0 ? void 0 : instance.state) === null || _a === void 0 ? void 0 : _a.indeterminateRows) === null || _b === void 0 ? void 0 : _b[row.id]) !== null && _c !== void 0 ? _c : false;
        }
        return [
            rowProps,
            {
                indeterminate: indeterminate,
                checked: indeterminate ? true : rowProps.checked
            }
        ];
    };
    const stateReducer = (newState, action, prevState, instance) => {
        var _a;
        if (action.type === 'INDETERMINATE_ROW_IDS') {
            if (action.payload === 'reset') {
                return Object.assign(Object.assign({}, newState), { indeterminateRows: {} });
            }
            let indeterminateRows = {};
            const allSelectedRows = {};
            let allSelected = true;
            let currentDepth = -1;
            (_a = instance.flatRows) === null || _a === void 0 ? void 0 : _a.filter((item) => !item.original.emptyRow).sort((a, b) => b.id.localeCompare(a.id)).map((item) => {
                if (currentDepth === -1) {
                    currentDepth = item.depth;
                }
                else if (currentDepth !== item.depth) {
                    currentDepth = item.depth;
                    if (allSelected && newState.selectedRowIds[item.id]) {
                        allSelectedRows[item.id] = true;
                        delete indeterminateRows[item.id];
                    }
                    allSelected = true;
                }
                if (newState.selectedRowIds[item.id]) {
                    const parentRowId = item.id.slice(0, item.id.lastIndexOf('.'));
                    if (parentRowId) {
                        indeterminateRows = Object.assign(Object.assign({}, indeterminateRows), getParentIndicesRecursive(item.id));
                    }
                }
                else {
                    allSelected = false;
                }
                return item;
            });
            return Object.assign(Object.assign({}, newState), { indeterminateRows: indeterminateRows });
        }
    };
    const useInstanceAfterData = (instance) => {
        const { data, dispatch, state: { selectedRowIds, indeterminateRows }, webComponentsReactProperties: { selectionMode, selectionBehavior, isTreeTable } } = instance;
        useEffect(() => {
            if (isTreeTable &&
                selectionMode === TableSelectionMode.MultiSelect &&
                selectionBehavior !== TableSelectionBehavior.RowOnly) {
                dispatch({ type: 'INDETERMINATE_ROW_IDS' });
            }
            else if (typeof indeterminateRows === 'object' && Object.keys(indeterminateRows).length) {
                dispatch({ type: 'INDETERMINATE_ROW_IDS', payload: 'reset' });
            }
        }, [data, selectedRowIds, isTreeTable, selectionMode, selectionBehavior]);
    };
    const useIndeterminate = (hooks) => {
        hooks.getToggleRowSelectedProps.push(toggleRowProps);
        hooks.stateReducers.push(stateReducer);
        hooks.useInstanceAfterData.push(useInstanceAfterData);
    };
    useIndeterminate.pluginName = 'useIndeterminate';
    return useIndeterminate;
};
