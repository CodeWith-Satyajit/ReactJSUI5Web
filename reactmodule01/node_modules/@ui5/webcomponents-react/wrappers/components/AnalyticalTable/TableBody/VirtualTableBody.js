import { useVirtualizer } from '@tanstack/react-virtual';
import '@ui5/webcomponents-icons/dist/navigation-down-arrow.js';
import '@ui5/webcomponents-icons/dist/navigation-right-arrow.js';
import React, { useMemo } from 'react';
import { RowSubComponent as SubComponent } from './RowSubComponent';
const measureElement = (el) => el.offsetHeight;
export const VirtualTableBody = (props) => {
    const { classes, prepareRow, rows, minRows, scrollToRef, isTreeTable, internalRowHeight, visibleRows, overscanCount, visibleColumns, parentRef, renderRowSubComponent, popInRowHeight, markNavigatedRow, isRtl, alwaysShowSubComponent, dispatch, subComponentsHeight, columnVirtualizer } = props;
    const itemCount = Math.max(minRows, rows.length);
    const overscan = overscanCount ? overscanCount : Math.floor(visibleRows / 2);
    const rowHeight = popInRowHeight !== internalRowHeight ? popInRowHeight : internalRowHeight;
    const rowVirtualizer = useVirtualizer({
        count: itemCount,
        getScrollElement: () => parentRef.current,
        estimateSize: React.useCallback((index) => {
            var _a, _b, _c, _d, _e;
            if (renderRowSubComponent &&
                (((_a = rows[index]) === null || _a === void 0 ? void 0 : _a.isExpanded) || alwaysShowSubComponent) &&
                ((_b = subComponentsHeight === null || subComponentsHeight === void 0 ? void 0 : subComponentsHeight[index]) === null || _b === void 0 ? void 0 : _b.rowId) === ((_c = rows[index]) === null || _c === void 0 ? void 0 : _c.id)) {
                return rowHeight + ((_e = (_d = subComponentsHeight === null || subComponentsHeight === void 0 ? void 0 : subComponentsHeight[index]) === null || _d === void 0 ? void 0 : _d.subComponentHeight) !== null && _e !== void 0 ? _e : 0);
            }
            return rowHeight;
        }, [rowHeight, rows, renderRowSubComponent, alwaysShowSubComponent, subComponentsHeight]),
        overscan,
        measureElement
    });
    scrollToRef.current = Object.assign(Object.assign({}, scrollToRef.current), { scrollToOffset: rowVirtualizer.scrollToOffset, scrollToIndex: rowVirtualizer.scrollToIndex });
    const popInColumn = useMemo(() => visibleColumns.filter((item) => item.id !== '__ui5wcr__internal_highlight_column' &&
        item.id !== '__ui5wcr__internal_selection_column' &&
        item.id !== '__ui5wcr__internal_navigation_column')[0], [visibleColumns]);
    return (React.createElement("div", { "data-component-name": "AnalyticalTableBodyScrollableContainer", style: {
            position: 'relative',
            height: `${rowVirtualizer.getTotalSize()}px`,
            width: `${columnVirtualizer.getTotalSize()}px`
        } }, rowVirtualizer.getVirtualItems().map((virtualRow, visibleRowIndex) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const row = rows[virtualRow.index];
        const rowIndexWithHeader = virtualRow.index + 1;
        if (!row || row.groupByVal === 'undefined') {
            return (React.createElement("div", { key: `empty_row_${virtualRow.index}`, className: classes.tr, style: {
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${virtualRow.start}px)`,
                    boxSizing: 'border-box'
                } }));
        }
        prepareRow(row);
        const rowProps = row.getRowProps();
        const isNavigatedCell = markNavigatedRow(row);
        const RowSubComponent = typeof renderRowSubComponent === 'function' ? renderRowSubComponent(row) : undefined;
        if (!RowSubComponent && subComponentsHeight && ((_a = subComponentsHeight === null || subComponentsHeight === void 0 ? void 0 : subComponentsHeight[virtualRow.index]) === null || _a === void 0 ? void 0 : _a.subComponentHeight)) {
            dispatch({
                type: 'SUB_COMPONENTS_HEIGHT',
                payload: Object.assign(Object.assign({}, subComponentsHeight), { [virtualRow.index]: { subComponentHeight: 0, rowId: row.id } })
            });
        }
        let updatedHeight = rowHeight;
        if (renderRowSubComponent &&
            (((_b = rows[virtualRow.index]) === null || _b === void 0 ? void 0 : _b.isExpanded) || alwaysShowSubComponent) &&
            ((_c = subComponentsHeight === null || subComponentsHeight === void 0 ? void 0 : subComponentsHeight[virtualRow.index]) === null || _c === void 0 ? void 0 : _c.rowId) === ((_d = rows[virtualRow.index]) === null || _d === void 0 ? void 0 : _d.id)) {
            updatedHeight += (_f = (_e = subComponentsHeight === null || subComponentsHeight === void 0 ? void 0 : subComponentsHeight[virtualRow.index]) === null || _e === void 0 ? void 0 : _e.subComponentHeight) !== null && _f !== void 0 ? _f : 0;
        }
        return (
        // eslint-disable-next-line react/jsx-key
        React.createElement("div", Object.assign({}, rowProps, { style: Object.assign(Object.assign({}, ((_g = rowProps.style) !== null && _g !== void 0 ? _g : {})), { transform: `translateY(${virtualRow.start}px)`, position: 'absolute', boxSizing: 'border-box', height: `${updatedHeight}px` }), ref: (node) => {
                virtualRow.measureElement(node);
            }, "aria-rowindex": virtualRow.index + 1 }),
            RowSubComponent && (row.isExpanded || alwaysShowSubComponent) && (React.createElement(SubComponent, { subComponentsHeight: subComponentsHeight, virtualRow: virtualRow, dispatch: dispatch, row: row, rowHeight: rowHeight, rows: rows, alwaysShowSubComponent: alwaysShowSubComponent }, RowSubComponent)),
            columnVirtualizer.getVirtualItems().map((virtualColumn, visibleColumnIndex) => {
                var _a;
                const cell = row.cells[virtualColumn.index];
                const directionStyles = isRtl
                    ? {
                        transform: `translateX(-${virtualColumn.start}px)`,
                        right: 0
                    }
                    : { transform: `translateX(${virtualColumn.start}px)`, left: 0 };
                if (!cell) {
                    return null;
                }
                const cellProps = cell.getCellProps();
                const allCellProps = Object.assign(Object.assign({}, cellProps), { ['data-visible-column-index']: visibleColumnIndex, ['data-column-index']: virtualColumn.index, ['data-visible-row-index']: visibleRowIndex + 1, ['data-row-index']: rowIndexWithHeader, style: Object.assign(Object.assign(Object.assign({}, cellProps.style), { position: 'absolute', width: `${virtualColumn.size}px`, top: 0, height: `${rowHeight}px` }), directionStyles) });
                if ((_a = row.original) === null || _a === void 0 ? void 0 : _a.emptyRow) {
                    // eslint-disable-next-line react/jsx-key
                    return React.createElement("div", Object.assign({}, allCellProps));
                }
                let contentToRender;
                if (cell.column.id === '__ui5wcr__internal_highlight_column' ||
                    cell.column.id === '__ui5wcr__internal_selection_column' ||
                    cell.column.id === '__ui5wcr__internal_navigation_column') {
                    contentToRender = 'Cell';
                }
                else if (isTreeTable || (!alwaysShowSubComponent && RowSubComponent)) {
                    contentToRender = 'Expandable';
                }
                else if (cell.isGrouped) {
                    contentToRender = 'Grouped';
                }
                else if (cell.isAggregated) {
                    contentToRender = 'Aggregated';
                }
                else if (cell.isPlaceholder) {
                    contentToRender = 'RepeatedValue';
                }
                else {
                    contentToRender = 'Cell';
                }
                return (
                // eslint-disable-next-line react/jsx-key
                React.createElement("div", Object.assign({}, allCellProps, { "data-selection-cell": cell.column.id === '__ui5wcr__internal_selection_column' }), popInRowHeight !== internalRowHeight && popInColumn.id === cell.column.id
                    ? cell.render('PopIn', { contentToRender, internalRowHeight })
                    : cell.render(contentToRender, isNavigatedCell === true ? { isNavigatedCell } : {})));
            })));
    })));
};
