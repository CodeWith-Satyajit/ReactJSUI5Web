import { CssSizeVariables, ThemingParameters, useCurrentTheme, useI18nBundle, useIsRTL, useSyncRef } from '@ui5/webcomponents-react-base';
import React, { forwardRef, useEffect, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { ButtonDesign } from '../../enums';
import { PRESS_ARROW_KEYS_TO_MOVE } from '../../i18n/i18n-defaults';
import { CustomThemingParameters } from '../../themes/CustomVariables';
import { Button, Icon } from '../../webComponents';
const useStyles = createUseStyles({
    splitter: {
        touchAction: 'none',
        position: 'relative',
        display: 'flex',
        willChange: 'flex',
        backgroundColor: ThemingParameters.sapShell_Background,
        alignItems: 'center',
        justifyContent: 'center',
        boxSizing: 'border-box',
        '&[data-splitter-vertical=horizontal]': {
            cursor: 'col-resize',
            borderLeft: CustomThemingParameters.SplitterBarBorderStyle,
            borderRight: CustomThemingParameters.SplitterBarBorderStyle,
            minWidth: CssSizeVariables.sapWcrSplitterSize,
            width: CssSizeVariables.sapWcrSplitterSize,
            height: '100%',
            flexDirection: 'column',
            '&:focus': {
                borderTop: CustomThemingParameters.SplitterBarBorderFix,
                borderRight: CustomThemingParameters.SplitterBarBorderFocus,
                borderBottom: CustomThemingParameters.SplitterBarBorderFix,
                borderLeft: CustomThemingParameters.SplitterBarBorderFocus,
                outlineOffset: '-0.20rem',
                outline: CustomThemingParameters.SplitterBarOutline
            },
            '& $lineBefore, & $lineAfter': {
                backgroundSize: '0.0625rem 100%',
                width: CssSizeVariables.sapWcrSplitterSize,
                height: '4rem'
            },
            '& $lineBefore': {
                backgroundImage: `linear-gradient(to top, ${CustomThemingParameters.SplitterContentBorderColor}, transparent)`
            },
            '& $icon': {
                padding: '0.5rem 0',
                zIndex: 1
            },
            '& $lineAfter': {
                backgroundImage: `linear-gradient(to bottom, ${CustomThemingParameters.SplitterContentBorderColor}, transparent)`
            }
        },
        '&[data-splitter-vertical=vertical]': {
            borderTop: CustomThemingParameters.SplitterBarBorderStyle,
            borderBottom: CustomThemingParameters.SplitterBarBorderStyle,
            cursor: 'row-resize',
            minHeight: CssSizeVariables.sapWcrSplitterSize,
            height: CssSizeVariables.sapWcrSplitterSize,
            width: '100%',
            flexDirection: 'row',
            '&:focus': {
                borderTop: CustomThemingParameters.SplitterBarBorderFocus,
                borderRight: CustomThemingParameters.SplitterBarBorderFix,
                borderBottom: CustomThemingParameters.SplitterBarBorderFocus,
                borderLeft: CustomThemingParameters.SplitterBarBorderFix,
                outlineOffset: '-0.20rem',
                outline: CustomThemingParameters.SplitterBarOutline
            },
            '& $lineBefore, & $lineAfter': {
                backgroundSize: '100% 0.0625rem ',
                width: '5rem',
                height: CssSizeVariables.sapWcrSplitterSize
            },
            '& $lineBefore': {
                backgroundImage: `linear-gradient(to left, ${CustomThemingParameters.SplitterContentBorderColor}, transparent)`
            },
            '& $icon': {
                padding: '0 0.5rem',
                zIndex: 1
            },
            '& $lineAfter': {
                backgroundImage: `linear-gradient(to right, ${CustomThemingParameters.SplitterContentBorderColor}, transparent)`
            }
        },
        '&[data-splitter-vertical=verticalRtl]': {
            cursor: 'row-resize',
            minHeight: CssSizeVariables.sapWcrSplitterSize,
            height: CssSizeVariables.sapWcrSplitterSize,
            width: '100%',
            flexDirection: 'row',
            '& $lineBefore, & $lineAfter': {
                backgroundSize: '100% 0.0625rem ',
                width: '5rem',
                height: CssSizeVariables.sapWcrSplitterSize
            },
            '& $lineBefore': {
                backgroundImage: `linear-gradient(to right, ${CustomThemingParameters.SplitterContentBorderColor}, transparent)`
            },
            '& $icon': {
                padding: '0 0.5rem',
                zIndex: 1
            },
            '& $lineAfter': {
                backgroundImage: `linear-gradient(to left, ${CustomThemingParameters.SplitterContentBorderColor}, transparent)`
            }
        },
        '&:hover': {
            '& $lineBefore, & $lineAfter': {
                flexGrow: 1,
                transition: 'all 0.1s ease-in'
            }
        }
    },
    gripButton: {
        minWidth: '1.5rem !important',
        height: '1.625rem',
        zIndex: '1',
        '&:active': {
            zIndex: '2'
        }
    },
    icon: {
        color: CustomThemingParameters.SplitterIconColor
    },
    lineBefore: {
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat'
    },
    lineAfter: {
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat'
    }
}, { name: 'Splitter' });
const verticalPositionInfo = {
    start: 'top',
    end: 'bottom',
    position: 'Y',
    positionRect: 'y',
    size: 'height',
    min: 'minHeight',
    offset: 'offsetY'
};
const horizontalPositionInfo = {
    start: 'left',
    end: 'right',
    position: 'X',
    positionRect: 'x',
    size: 'width',
    min: 'minWidth',
    offset: 'offsetX'
};
const Splitter = forwardRef((props, ref) => {
    var _a;
    const { vertical } = props;
    const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
    const [componentRef, localRef] = useSyncRef(ref);
    const isRtl = useIsRTL({ current: (_a = localRef.current) === null || _a === void 0 ? void 0 : _a.parentElement });
    const start = useRef(null);
    const classes = useStyles();
    const previousSiblingSize = useRef(null);
    const nextSiblingSize = useRef(null);
    const previousElementEnd = useRef(null);
    const nextElementStart = useRef(null);
    const resizerClickOffset = useRef(0);
    const positionKeys = vertical ? verticalPositionInfo : horizontalPositionInfo;
    const [isDragging, setIsDragging] = useState(false);
    const [isSiblings, setIsSiblings] = useState(['previousSibling', 'nextSibling']);
    const handleSplitterMove = (e) => {
        const offset = resizerClickOffset.current;
        const previousSibling = localRef.current[isSiblings[0]];
        const nextSibling = localRef.current[isSiblings[1]];
        const currentPosition = isDragging === 'touch' ? e.touches[0][`client${positionKeys.position}`] : e[`client${positionKeys.position}`];
        const sizeDiv = currentPosition - start.current;
        const splitterWidth = localRef.current.getBoundingClientRect()[positionKeys.size];
        const moveLeft = sizeDiv < 0;
        const move = () => {
            previousSibling.style.flex = `0 0 ${previousSiblingSize.current + sizeDiv}px`;
            if (nextSibling.nextSibling && previousSiblingSize.current + sizeDiv > 0) {
                nextSibling.style.flex = `0 0 ${nextSiblingSize.current - sizeDiv}px`;
            }
        };
        if (previousSiblingSize.current + sizeDiv > 0 &&
            currentPosition + (splitterWidth - offset) <= nextElementStart.current) {
            if (parseInt(previousSibling.dataset.minSize, 10) <= previousSiblingSize.current + sizeDiv && moveLeft) {
                move();
            }
            if (nextSiblingSize.current - sizeDiv >= parseInt(nextSibling.dataset.minSize, 10) && !moveLeft) {
                move();
            }
        }
        if (!nextSibling[isSiblings[1]] && !isRtl) {
            nextSibling.style.flex = '1 0 0px';
        }
    };
    const handleFallback = (e, touchEvent) => {
        var _a, _b, _c, _d, _e;
        const prevSibling = localRef.current[isSiblings[0]];
        const nextSibling = localRef.current[isSiblings[1]];
        const prevSiblingRect = localRef.current[isSiblings[0]].getBoundingClientRect();
        const nextSiblingRect = localRef.current[isSiblings[1]].getBoundingClientRect();
        const currentPos = touchEvent
            ? Math.round(e.changedTouches[0][`client${positionKeys.position}`])
            : e[`client${positionKeys.position}`];
        // left
        if (currentPos - ((_a = localRef.current.getBoundingClientRect()) === null || _a === void 0 ? void 0 : _a[positionKeys.positionRect]) < 0) {
            prevSibling.style.flex = '0 0 0px';
            // Check if minSize is set on previous sibling
            if ((_b = prevSibling.style) === null || _b === void 0 ? void 0 : _b[positionKeys.min]) {
                nextSibling.style.flex = `0 0 ${(nextSiblingRect === null || nextSiblingRect === void 0 ? void 0 : nextSiblingRect[positionKeys.size]) +
                    ((prevSiblingRect === null || prevSiblingRect === void 0 ? void 0 : prevSiblingRect[positionKeys.size]) - ((_c = prevSibling.style) === null || _c === void 0 ? void 0 : _c[positionKeys.min].replace('px', '')))}px`;
            }
            else {
                nextSibling.style.flex = `0 0 ${(nextSiblingRect === null || nextSiblingRect === void 0 ? void 0 : nextSiblingRect[positionKeys.size]) + (prevSiblingRect === null || prevSiblingRect === void 0 ? void 0 : prevSiblingRect[positionKeys.size])}px`;
            }
        }
        // right
        if (nextElementStart.current < currentPos) {
            nextSibling.style.flex = '0 0 0px';
            // Check if minSize is set on next sibling
            if ((_d = nextSibling.style) === null || _d === void 0 ? void 0 : _d[positionKeys.min]) {
                prevSibling.style.flex = `0 0 ${(prevSiblingRect === null || prevSiblingRect === void 0 ? void 0 : prevSiblingRect[positionKeys.size]) +
                    ((nextSiblingRect === null || nextSiblingRect === void 0 ? void 0 : nextSiblingRect[positionKeys.size]) - ((_e = nextSibling.style) === null || _e === void 0 ? void 0 : _e[positionKeys.min].replace('px', '')))}px`;
            }
            else {
                prevSibling.style.flex = `0 0 ${(prevSiblingRect === null || prevSiblingRect === void 0 ? void 0 : prevSiblingRect[positionKeys.size]) + (nextSiblingRect === null || nextSiblingRect === void 0 ? void 0 : nextSiblingRect[positionKeys.size])}px`;
            }
        }
    };
    const handleSplitterClick = (e) => {
        e.currentTarget.focus();
    };
    const handleMoveSplitterStart = (e) => {
        var _a, _b, _c, _d, _e;
        if (e.type === 'pointerdown' && e.pointerType !== 'touch') {
            return;
        }
        e.preventDefault();
        setIsDragging((_a = e.pointerType) !== null && _a !== void 0 ? _a : 'mouse');
        resizerClickOffset.current = e.nativeEvent[positionKeys.offset];
        previousElementEnd.current = (_b = localRef.current[isSiblings[0]].getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b[positionKeys.end];
        if (localRef.current[isSiblings[1]][isSiblings[1]]) {
            nextElementStart.current = (_c = localRef.current[isSiblings[1]][isSiblings[1]].getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c[positionKeys.start];
        }
        else {
            nextElementStart.current = localRef.current.parentElement.getBoundingClientRect()[positionKeys.end];
        }
        previousSiblingSize.current = (_d = localRef.current[isSiblings[0]].getBoundingClientRect()) === null || _d === void 0 ? void 0 : _d[positionKeys.size];
        nextSiblingSize.current = (_e = localRef.current[isSiblings[1]].getBoundingClientRect()) === null || _e === void 0 ? void 0 : _e[positionKeys.size];
        start.current = e[`client${positionKeys.position}`];
    };
    const onHandleKeyDown = (e) => {
        var _a, _b, _c, _d, _e;
        const keyEventProperties = (_a = e.code) !== null && _a !== void 0 ? _a : e.key;
        if (keyEventProperties === 'ArrowRight' ||
            keyEventProperties === 'ArrowLeft' ||
            keyEventProperties === 'ArrowUp' ||
            keyEventProperties === 'ArrowDown') {
            e.preventDefault();
            let firstSibling = localRef.current[isSiblings[0]];
            let secondSibling = localRef.current[isSiblings[1]];
            if (keyEventProperties === 'ArrowLeft' || keyEventProperties === 'ArrowUp') {
                secondSibling = localRef.current[isSiblings[0]];
                firstSibling = localRef.current[isSiblings[1]];
            }
            const remainingSize = secondSibling.style[positionKeys.min]
                ? ((_b = secondSibling.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b[positionKeys.size]) -
                    Number(secondSibling.style[positionKeys.min].replace('px', ''))
                : (_c = secondSibling.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c[positionKeys.size];
            if (document.activeElement === localRef.current) {
                const tickSize = remainingSize >= 20 ? 20 : remainingSize;
                secondSibling.style.flex = `0 0 ${((_d = secondSibling.getBoundingClientRect()) === null || _d === void 0 ? void 0 : _d[positionKeys.size]) - tickSize}px`;
                firstSibling.style.flex = `0 0 ${((_e = firstSibling.getBoundingClientRect()) === null || _e === void 0 ? void 0 : _e[positionKeys.size]) + tickSize}px`;
            }
        }
    };
    const end = (e) => {
        handleFallback(e, isDragging === 'touch');
        setIsDragging(false);
    };
    useEffect(() => {
        const removeEventListeners = () => {
            if (isDragging === 'touch') {
                document.removeEventListener('touchmove', handleSplitterMove);
                document.removeEventListener('touchend', end);
            }
            else {
                document.removeEventListener('mouseup', end);
                document.removeEventListener('mousemove', handleSplitterMove);
            }
        };
        if (isDragging) {
            if (isDragging === 'touch') {
                document.addEventListener('touchmove', handleSplitterMove);
                document.addEventListener('touchend', end);
            }
            else {
                document.addEventListener('mousemove', handleSplitterMove);
                document.addEventListener('mouseup', end);
            }
        }
        else {
            removeEventListeners();
        }
        return () => {
            removeEventListeners();
        };
    }, [isDragging]);
    useEffect(() => {
        setIsSiblings(isRtl && !vertical ? ['nextSibling', 'previousSibling'] : ['previousSibling', 'nextSibling']);
    }, [isRtl, vertical]);
    const currentTheme = useCurrentTheme();
    const isHighContrast = currentTheme === 'sap_fiori_3_hcb' ||
        currentTheme === 'sap_fiori_3_hcw' ||
        currentTheme === 'sap_horizon_hcb' ||
        currentTheme === 'sap_horizon_hcw';
    return (React.createElement("div", { className: classes.splitter, tabIndex: 0, onClick: handleSplitterClick, onKeyDown: onHandleKeyDown, onPointerDown: handleMoveSplitterStart, onMouseDown: handleMoveSplitterStart, ref: componentRef, role: "separator", "data-splitter-vertical": isRtl && vertical ? 'verticalRtl' : vertical ? 'vertical' : 'horizontal', title: i18nBundle.getText(PRESS_ARROW_KEYS_TO_MOVE), "aria-orientation": vertical ? 'vertical' : 'horizontal', "aria-label": i18nBundle.getText(PRESS_ARROW_KEYS_TO_MOVE) },
        React.createElement("div", { className: classes.lineBefore }),
        isHighContrast ? (React.createElement(Button, { className: classes.gripButton, tabIndex: -1, icon: vertical ? 'horizontal-grip' : 'vertical-grip', design: ButtonDesign.Transparent })) : (React.createElement(Icon, { className: classes.icon, name: vertical ? 'horizontal-grip' : 'vertical-grip' })),
        React.createElement("div", { className: classes.lineAfter })));
});
Splitter.displayName = 'Splitter';
export { Splitter };
