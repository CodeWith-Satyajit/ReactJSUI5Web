{"ast":null,"code":"import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/direction-arrows.js\";\nimport { isEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown } from \"@ui5/webcomponents-base/dist/Keys.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n  properties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */{\n    /**\n     * Defines the minimum value of the slider.\n     *\n     * @type {sap.ui.webcomponents.base.types.Float}\n     * @defaultvalue 0\n     * @public\n     */\n    min: {\n      type: Float,\n      defaultValue: 0\n    },\n    /**\n     * Defines the maximum value of the slider.\n     *\n     * @type {sap.ui.webcomponents.base.types.Float}\n     * @defaultvalue 100\n     * @public\n     */\n    max: {\n      type: Float,\n      defaultValue: 100\n    },\n    /**\n     * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n     * <br><br>\n     * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n     *\n     * @type {sap.ui.webcomponents.base.types.Integer}\n     * @defaultvalue 1\n     * @public\n     */\n    step: {\n      type: Float,\n      defaultValue: 1\n    },\n    /**\n     * Displays a label with a value on every N-th step.\n     * <br><br>\n     * <b>Note:</b> The step and tickmarks properties must be enabled.\n     * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n     * tickmark will be labelled, which means every 4th value number.\n     *\n     * @type {sap.ui.webcomponents.base.types.Integer}\n     * @defaultvalue 0\n     * @public\n     */\n    labelInterval: {\n      type: Integer,\n      defaultValue: 0\n    },\n    /**\n     * Enables tickmarks visualization for each step.\n     * <br><br>\n     * <b>Note:</b> The step must be a positive number.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTickmarks: {\n      type: Boolean\n    },\n    /**\n     * Enables handle tooltip displaying the current value.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTooltip: {\n      type: Boolean\n    },\n    /**\n     * Defines whether the slider is in disabled state.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    disabled: {\n      type: Boolean\n    },\n    /**\n     * Defines the accessible ARIA name of the component.\n     *\n     * @type {string}\n     * @defaultvalue: \"\"\n     * @public\n     * @since 1.4.0\n     */\n    accessibleName: {\n      type: String\n    },\n    /**\n     * @private\n     */\n    _tooltipVisibility: {\n      type: String,\n      defaultValue: \"hidden\"\n    },\n    _labelsOverlapping: {\n      type: Boolean\n    },\n    _hiddenTickmarks: {\n      type: Boolean\n    }\n  },\n  events: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */{\n    /**\n     * Fired when the value changes and the user has finished interacting with the slider.\n     *\n     * @event\n     * @public\n    */\n    change: {},\n    /**\n     * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n     *\n     * @event\n     * @public\n    */\n    input: {}\n  }\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n  constructor() {\n    super();\n    this._resizeHandler = this._handleResize.bind(this);\n    this._moveHandler = this._handleMove.bind(this);\n    this._upHandler = this._handleUp.bind(this);\n    this._stateStorage = {\n      step: null,\n      min: null,\n      max: null,\n      labelInterval: null\n    };\n    const handleTouchStartEvent = event => {\n      this._onmousedown(event);\n    };\n    this._ontouchstart = {\n      handleEvent: handleTouchStartEvent,\n      passive: true\n    };\n  }\n  static get metadata() {\n    return metadata;\n  }\n  static get render() {\n    return litRender;\n  }\n  static get styles() {\n    return styles;\n  }\n  static get UP_EVENTS() {\n    return [\"mouseup\", \"touchend\"];\n  }\n  static get MOVE_EVENT_MAP() {\n    return {\n      mousedown: \"mousemove\",\n      touchstart: \"touchmove\"\n    };\n  }\n  static get ACTION_KEYS() {\n    return [isLeft, isRight, isUp, isDown, isLeftCtrl, isRightCtrl, isUpCtrl, isDownCtrl, isPlus, isMinus, isHome, isEnd, isPageUp, isPageDown, isEscape];\n  }\n  static get MIN_SPACE_BETWEEN_TICKMARKS() {\n    return 8;\n  }\n  static get TOOLTIP_VISIBILITY() {\n    return {\n      VISIBLE: \"visible\",\n      HIDDEN: \"hidden\"\n    };\n  }\n  get classes() {\n    return {\n      root: {\n        \"ui5-slider-root-phone\": isPhone()\n      },\n      labelContainer: {\n        \"ui5-slider-hidden-labels\": this._labelsOverlapping\n      }\n    };\n  }\n  onEnterDOM() {\n    ResizeHandler.register(this, this._resizeHandler);\n  }\n  onExitDOM() {\n    ResizeHandler.deregister(this, this._handleResize);\n  }\n  onAfterRendering() {\n    // Only call if the resize is triggered by a state changes other than\n    // the ones that occured on the previous resize and those caused by user interaction.\n    if (this.notResized) {\n      this._resizeHandler();\n    }\n  }\n\n  /** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n   *\n   * @private\n   */\n  _onmouseover(event) {\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n\n  /**\n   * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n   *\n   * @private\n   */\n  _onmouseout(event) {\n    if (this.showTooltip && !this.shadowRoot.activeElement) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n\n  /**\n   * Sets initial value when the component is focused in, can be restored with ESC key\n   *\n   * @private\n   */\n  _setInitialValue(valueType, value) {\n    this[`_${valueType}Initial`] = value;\n  }\n  _getInitialValue(valueType) {\n    return this[`_${valueType}Initial`];\n  }\n  _onkeydown(event) {\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n    if (SliderBase._isActionKey(event)) {\n      event.preventDefault();\n      this._isUserInteraction = true;\n      this._handleActionKeyPress(event);\n    }\n  }\n  _onkeyup(event) {\n    if (this.disabled) {\n      return;\n    }\n    this._isUserInteraction = false;\n  }\n\n  /**\n   * Flags if an inner element is currently being focused\n   *\n   * @private\n   */\n  _preserveFocus(isFocusing) {\n    this._isInnerElementFocusing = isFocusing;\n  }\n\n  /**\n   * Return if an inside element within the component is currently being focused\n   *\n   * @private\n   */\n  _isFocusing() {\n    return this._isInnerElementFocusing;\n  }\n\n  /**\n   * Prevent focus out when inner element within the component is currently being in process of focusing in.\n   * In theory this can be achieved either if the shadow root is focusable and 'delegatesFocus' attribute of\n   * the .attachShadow() customElement method is set to true, or if we forward it manually.\n  \t * As we use lit-element as base of our core UI5 element class that 'delegatesFocus' property is not set to 'true' and\n   * we have to manage the focus here. If at some point in the future this changes, the focus delegating logic could be\n   * removed as it will become redundant.\n   *\n   * When we manually set the focus on mouseDown to the first focusable element inside the shadowDom,\n   * that inner focus (shadowRoot.activeElement) is set a moment before the global document.activeElement\n   * is set to the customElement (ui5-slider) causing a 'race condition'.\n   *\n   * In order for a element within the shadowRoot to be focused, the global document.activeElement MUST be the parent\n   * customElement of the shadow root, in our case the ui5-slider component. Because of that after our focusin of the handle,\n   * a focusout event fired by the browser immidiatly after, resetting the focus. Focus out must be manually prevented\n   * in both initial focusing and switching the focus between inner elements of the component cases.\n  \t * Note: If we set the focus to the handle with a timeout or a bit later in time, on a mouseup or click event it will\n   * work fine and we will avoid the described race condition as our host customElement will be already finished focusing.\n   * However, that does not work for us as we need the focus to be set to the handle exactly on mousedown,\n   * because of the nature of the component and its available drag interactions.\n   *\n   * @private\n   */\n  _preventFocusOut() {\n    this.focusInnerElement();\n  }\n\n  /**\n   * Manages the focus between the component's inner elements\n   * @protected\n   */\n  focusInnerElement() {\n    this.focus();\n  }\n\n  /**\n   * Handle the responsiveness of the Slider's UI elements when resizing\n   *\n   * @private\n   */\n  _handleResize() {\n    if (!this.showTickmarks) {\n      return;\n    }\n\n    // Mark resizing to avoid unneccessary calls to that function after rendering\n    this.notResized = false;\n\n    // Convert the string represented calculation expression to a normal one\n    // Check the distance  in pixels exist between every tickmark\n    const spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n    // If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n    // In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n    if (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n      this._hiddenTickmarks = true;\n      this._labelsOverlapping = true;\n    } else {\n      this._hiddenTickmarks = false;\n    }\n    if (this.labelInterval <= 0 || this._hiddenTickmarks) {\n      return;\n    }\n\n    // Check if there are any overlapping labels.\n    // If so - only the first and the last one should be visible\n    const labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n    this._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n  }\n\n  /**\n   * Called when the user starts interacting with the slider.\n   * After a down event on the slider root, listen for move events on window, so the slider value\n   * is updated even if the user drags the pointer outside the slider root.\n   *\n   * @protected\n   */\n  handleDownBase(event) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const domRect = this.getBoundingClientRect();\n    const directionStart = this.directionStart;\n    const step = this._effectiveStep;\n    const newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n\n    // Mark start of a user interaction\n    this._isUserInteraction = true;\n    // Only allow one type of move event to be listened to (the first one registered after the down event)\n    this._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n    SliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n    window.addEventListener(this._moveEventType, this._moveHandler);\n    this._handleFocusOnMouseDown(event);\n    return newValue;\n  }\n\n  /**\n   * Forward the focus to an inner inner part within the component on press\n   *\n   * @private\n   */\n  _handleFocusOnMouseDown(event) {\n    const focusedElement = this.shadowRoot.activeElement;\n    if (!focusedElement || focusedElement !== event.target) {\n      this._preserveFocus(true);\n      this.focusInnerElement();\n    }\n  }\n\n  /**\n   * Called when the user finish interacting with the slider\n   * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n   *\n   * @protected\n   */\n  handleUpBase(valueType) {\n    SliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n    window.removeEventListener(this._moveEventType, this._moveHandler);\n    this._moveEventType = null;\n    this._isUserInteraction = false;\n    this._preserveFocus(false);\n  }\n\n  /**\n   * Updates value property of the component that has been changed due to a user action.\n   * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n   *\n   * @protected\n   */\n  updateValue(valueType, value) {\n    this[valueType] = value;\n    this.storePropertyState(valueType);\n    if (this._isUserInteraction) {\n      this.fireEvent(\"input\");\n    }\n  }\n\n  /**\n   * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n   *\n   * @private\n   */\n  static _isActionKey(event) {\n    return this.ACTION_KEYS.some(actionKey => actionKey(event));\n  }\n\n  /**\n   * Locks the given value between min and max boundaries based on slider properties\n   *\n   * @protected\n   */\n  static clipValue(value, min, max) {\n    value = Math.min(Math.max(value, min), max);\n    return value;\n  }\n\n  /**\n   * Sets the slider value from an event\n   *\n   * @protected\n   */\n  static getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n    const pageX = this.getPageXValueFromEvent(event);\n    const value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n    const steppedValue = this.getSteppedValue(value, stepSize, min);\n    return this.clipValue(steppedValue, min, max);\n  }\n\n  /**\n   * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n   *\n   * @protected\n   */\n  static getSteppedValue(value, stepSize, min) {\n    const stepModuloValue = Math.abs((value - min) % stepSize);\n    if (stepSize === 0 || stepModuloValue === 0) {\n      return value;\n    }\n\n    // Clip (snap) the new value to the nearest step\n    value = stepModuloValue * 2 >= stepSize ? value + stepSize - stepModuloValue : value - stepModuloValue;\n\n    // If the step value is not a round number get its precision\n    const stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n    return value.toFixed(stepPrecision);\n  }\n\n  /**\n   * Gets pageX value from event on user interaction with the Slider\n   *\n   * @protected\n   */\n  static getPageXValueFromEvent(event) {\n    if (event.targetTouches && event.targetTouches.length > 0) {\n      return event.targetTouches[0].pageX;\n    }\n    return event.pageX;\n  }\n\n  /**\n   * Computes the new value (in %) from the pageX position of the cursor.\n   * Returns the value rounded to a precision of at most 2 digits after decimal point.\n   *\n   * @protected\n   */\n  static computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n    // Determine pageX position relative to the Slider DOM\n    const xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n    // Calculate the percentage complete (the \"progress\")\n    const percentageComplete = xRelativePosition / boundingClientRect.width;\n    // Fit (map) the complete percentage between the min/max value range\n    return min + percentageComplete * (max - min);\n  }\n\n  /**\n   * Calculates the precision (decimal places) of a number, returns 0 if integer\n   * Handles scientific notation cases.\n   * @private\n   */\n  static _getDecimalPrecisionOfNumber(value) {\n    if (Number.isInteger(value)) {\n      return 0;\n    }\n    const match = String(value).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n  }\n\n  /**\n   * Normalize current properties, update the previously stored state.\n   *\n   * @protected\n   */\n  syncUIAndState() {\n    // Validate step and update the stored state for the step property.\n    if (this.isPropertyUpdated(\"step\")) {\n      this._validateStep(this.step);\n      this.storePropertyState(\"step\");\n    }\n\n    // Recalculate the tickmarks and labels and update the stored state.\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    if (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n      this.storePropertyState(\"min\", \"max\");\n\n      // Here the value props are changed programmatically (not by user interaction)\n      // and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n      // min and max bounderies and update the previous state reference.\n      values.forEach(valueType => {\n        const normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n        this.updateValue(valueType, normalizedValue);\n        this.storePropertyState(valueType);\n      });\n    }\n\n    // Labels must be updated if any of the min/max/step/labelInterval props are changed\n    if (this.labelInterval && this.showTickmarks) {\n      this._createLabels();\n    }\n\n    // Update the stored state for the labelInterval, if changed\n    if (this.isPropertyUpdated(\"labelInterval\")) {\n      this.storePropertyState(\"labelInterval\");\n    }\n  }\n\n  /**\n   * In order to always keep the visual UI representation and the internal\n   * state in sync, the component has a 'state storage' that is updated when the\n   * current state is changed due to a user action.\n   *\n   * Check if the previously saved state is outdated. That would mean\n   * a property has been changed programmatically because the previous state\n   * is always updated in the interaction handlers.\n   *\n   * Will return true if any of the properties is not equal to its previously\n   * stored value.\n   *\n   * @protected\n   */\n  isCurrentStateOutdated() {\n    return Object.entries(this._stateStorage).some(_ref => {\n      let [propName, propValue] = _ref;\n      return this[propName] !== propValue;\n    });\n  }\n\n  /**\n   * Returns the last stored value of a property\n   *\n   * @protected\n   */\n  getStoredPropertyState(property) {\n    return this._stateStorage[property];\n  }\n\n  /**\n   * Check if one or more properties have been updated compared to their last\n   * saved values in the state storage.\n   *\n   * @protected\n   */\n  isPropertyUpdated() {\n    for (var _len2 = arguments.length, properties = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      properties[_key2] = arguments[_key2];\n    }\n    return properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n  }\n\n  /**\n   * Updates the previously saved in the _stateStorage values of one or more properties.\n   *\n   * @protected\n   */\n  storePropertyState() {\n    for (var _len3 = arguments.length, props = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      props[_key3] = arguments[_key3];\n    }\n    props.forEach(property => {\n      this._stateStorage[property] = this[property];\n    });\n  }\n\n  /**\n   * Returns the start side of a direction - left for LTR, right for RTL\n   */\n  get directionStart() {\n    return this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n  }\n\n  /**\n   * Calculates the labels amout, width and text and creates them\n   *\n   * @private\n   */\n  _createLabels() {\n    if (!this.labelInterval || !this.showTickmarks) {\n      return;\n    }\n    const labelInterval = this.labelInterval;\n    const step = this._effectiveStep;\n    const newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n    // If the required labels are already rendered\n    if (newNumberOfLabels === this._oldNumberOfLabels) {\n      return;\n    }\n    this._oldNumberOfLabels = newNumberOfLabels;\n    this._labelWidth = 100 / newNumberOfLabels;\n    this._labelValues = [];\n\n    // If the step value is not a round number get its precision\n    const stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n    // numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n    // calculation to be precize (exactly the same as the distance between the tickmarks).\n    // That's ok as the loop stop condition is set to an integer, so it will practically\n    // \"floor\" the number of labels anyway.\n    for (let i = 0; i <= newNumberOfLabels; i++) {\n      // Format the label numbers with the same decimal precision as the value of the step property\n      const labelItemNumber = (i * step * labelInterval + this._effectiveMin).toFixed(stepPrecision);\n      this._labelValues.push(labelItemNumber);\n    }\n  }\n  _handleActionKeyPressBase(event, affectedValue) {\n    const isUpAction = SliderBase._isIncreaseValueAction(event);\n    const isBigStep = SliderBase._isBigStepAction(event);\n    const currentValue = this[affectedValue];\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n\n    // We need to take into consideration the effective direction of the slider - rtl or ltr.\n    // While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n    let step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep;\n\n    // If the action key corresponds to a long step and the slider has more than 10 normal steps,\n    // make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n    step = isBigStep && (max - min) / step > 10 ? (max - min) / 10 : step;\n    if (isEnd(event)) {\n      return max - currentValue;\n    }\n    if (isHome(event)) {\n      return (currentValue - min) * -1;\n    }\n    return isUpAction ? step : step * -1;\n  }\n  static _isDecreaseValueAction(event) {\n    return isDown(event) || isDownCtrl(event) || isLeft(event) || isLeftCtrl(event) || isMinus(event) || isPageDown(event);\n  }\n  static _isIncreaseValueAction(event) {\n    return isUp(event) || isUpCtrl(event) || isRight(event) || isRightCtrl(event) || isPlus(event) || isPageUp(event);\n  }\n  static _isBigStepAction(event) {\n    return isDownCtrl(event) || isUpCtrl(event) || isLeftCtrl(event) || isRightCtrl(event) || isPageUp(event) || isPageDown(event);\n  }\n  get _tickmarksCount() {\n    return (this._effectiveMax - this._effectiveMin) / this._effectiveStep;\n  }\n\n  /**\n   * Calculates space between tickmarks\n   *\n   * @private\n   */\n  _spaceBetweenTickmarks() {\n    return this.getBoundingClientRect().width / this._tickmarksCount;\n  }\n\n  /**\n   * Notify in case of a invalid step value type\n   *\n   * @private\n   */\n  _validateStep(step) {\n    if (step === 0) {\n      console.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n    }\n\n    if (step < 0) {\n      console.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n    }\n\n    if (typeof step !== \"number\" || Number.isNaN(step)) {\n      console.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n    }\n  }\n\n  get _labels() {\n    return this._labelValues || [];\n  }\n\n  /**\n   * Normalizes a new <code>step</code> property value.\n   * If tickmarks are enabled recreates them according to it.\n   *\n   * @private\n   */\n  get _effectiveStep() {\n    let step = this.step;\n    if (step < 0) {\n      step = Math.abs(step);\n    }\n    if (typeof step !== \"number\" || Number.isNaN(step)) {\n      step = 1;\n    }\n    return step;\n  }\n  get _effectiveMin() {\n    return Math.min(this.min, this.max);\n  }\n  get _effectiveMax() {\n    return Math.max(this.min, this.max);\n  }\n  get tabIndex() {\n    return this.disabled ? \"-1\" : \"0\";\n  }\n  get _ariaLabelledByHandleRefs() {\n    return [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n  }\n}\nexport default SliderBase;","map":{"version":3,"names":["UI5Element","litRender","Float","Integer","ResizeHandler","isPhone","isEscape","isHome","isEnd","isUp","isDown","isRight","isLeft","isUpCtrl","isDownCtrl","isRightCtrl","isLeftCtrl","isPlus","isMinus","isPageUp","isPageDown","styles","metadata","properties","min","type","defaultValue","max","step","labelInterval","showTickmarks","Boolean","showTooltip","disabled","accessibleName","String","_tooltipVisibility","_labelsOverlapping","_hiddenTickmarks","events","change","input","SliderBase","constructor","_resizeHandler","_handleResize","bind","_moveHandler","_handleMove","_upHandler","_handleUp","_stateStorage","handleTouchStartEvent","event","_onmousedown","_ontouchstart","handleEvent","passive","render","UP_EVENTS","MOVE_EVENT_MAP","mousedown","touchstart","ACTION_KEYS","MIN_SPACE_BETWEEN_TICKMARKS","TOOLTIP_VISIBILITY","VISIBLE","HIDDEN","classes","root","labelContainer","onEnterDOM","register","onExitDOM","deregister","onAfterRendering","notResized","_onmouseover","_onmouseout","shadowRoot","activeElement","_setInitialValue","valueType","value","_getInitialValue","_onkeydown","_effectiveStep","_isActionKey","preventDefault","_isUserInteraction","_handleActionKeyPress","_onkeyup","_preserveFocus","isFocusing","_isInnerElementFocusing","_isFocusing","_preventFocusOut","focusInnerElement","focus","spaceBetweenTickmarks","_spaceBetweenTickmarks","labelItems","querySelectorAll","some","label","scrollWidth","clientWidth","handleDownBase","_effectiveMin","_effectiveMax","domRect","getBoundingClientRect","directionStart","newValue","getValueFromInteraction","_moveEventType","forEach","upEventType","window","addEventListener","_handleFocusOnMouseDown","focusedElement","target","handleUpBase","removeEventListener","updateValue","storePropertyState","fireEvent","actionKey","clipValue","Math","stepSize","boundingClientRect","pageX","getPageXValueFromEvent","computedValueFromPageX","steppedValue","getSteppedValue","stepModuloValue","abs","stepPrecision","_getDecimalPrecisionOfNumber","toFixed","targetTouches","length","xRelativePosition","percentageComplete","width","Number","isInteger","match","syncUIAndState","isPropertyUpdated","_validateStep","values","normalizedValue","_createLabels","isCurrentStateOutdated","Object","entries","propName","propValue","getStoredPropertyState","property","prop","props","effectiveDir","newNumberOfLabels","_oldNumberOfLabels","_labelWidth","_labelValues","i","labelItemNumber","push","_handleActionKeyPressBase","affectedValue","isUpAction","_isIncreaseValueAction","isBigStep","_isBigStepAction","currentValue","_isDecreaseValueAction","_tickmarksCount","console","warn","isNaN","_labels","tabIndex","_ariaLabelledByHandleRefs","_id","join","trim"],"sources":["/home/user/projects/reactwithcap01/reactmodule01/node_modules/@ui5/webcomponents/dist/SliderBase.js"],"sourcesContent":["import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/direction-arrows.js\";\nimport {\n\tisEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\tproperties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */  {\n\t\t/**\n\t\t * Defines the minimum value of the slider.\n\t\t *\n\t\t * @type {sap.ui.webcomponents.base.types.Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tmin: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines the maximum value of the slider.\n\t\t *\n\t\t * @type {sap.ui.webcomponents.base.types.Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tmax: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t\t/**\n\t\t * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n\t\t * <br><br>\n\t\t * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n\t\t *\n\t\t * @type {sap.ui.webcomponents.base.types.Integer}\n\t\t * @defaultvalue 1\n\t\t * @public\n\t\t */\n\t\tstep: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 1,\n\t\t},\n\t\t/**\n\t\t * Displays a label with a value on every N-th step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step and tickmarks properties must be enabled.\n\t\t * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n\t\t * tickmark will be labelled, which means every 4th value number.\n\t\t *\n\t\t * @type {sap.ui.webcomponents.base.types.Integer}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tlabelInterval: {\n\t\t\ttype: Integer,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Enables tickmarks visualization for each step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step must be a positive number.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Enables handle tooltip displaying the current value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTooltip: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Defines whether the slider is in disabled state.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tdisabled: {\n\t\t\ttype: Boolean,\n\t\t},\n\n\t\t/**\n\t\t * Defines the accessible ARIA name of the component.\n\t\t *\n\t\t * @type {string}\n\t\t * @defaultvalue: \"\"\n\t\t * @public\n\t\t * @since 1.4.0\n\t\t */\n\t\t accessibleName: {\n\t\t\ttype: String,\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_tooltipVisibility: {\n\t\t\ttype: String,\n\t\t\tdefaultValue: \"hidden\",\n\t\t},\n\t\t_labelsOverlapping: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t_hiddenTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t},\n\tevents: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */ {\n\t\t/**\n\t\t * Fired when the value changes and the user has finished interacting with the slider.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tchange: {},\n\t\t/**\n\t\t * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tinput: {},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._resizeHandler = this._handleResize.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._upHandler = this._handleUp.bind(this);\n\n\t\tthis._stateStorage = {\n\t\t\tstep: null,\n\t\t\tmin: null,\n\t\t\tmax: null,\n\t\t\tlabelInterval: null,\n\t\t};\n\n\t\tconst handleTouchStartEvent = event => {\n\t\t\tthis._onmousedown(event);\n\t\t};\n\n\t\tthis._ontouchstart = {\n\t\t\thandleEvent: handleTouchStartEvent,\n\t\t\tpassive: true,\n\t\t};\n\t}\n\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get render() {\n\t\treturn litRender;\n\t}\n\n\tstatic get styles() {\n\t\treturn styles;\n\t}\n\n\tstatic get UP_EVENTS() {\n\t\treturn [\"mouseup\", \"touchend\"];\n\t}\n\n\tstatic get MOVE_EVENT_MAP() {\n\t\treturn {\n\t\t\tmousedown: \"mousemove\",\n\t\t\ttouchstart: \"touchmove\",\n\t\t};\n\t}\n\n\tstatic get ACTION_KEYS() {\n\t\treturn [\n\t\t\tisLeft,\n\t\t\tisRight,\n\t\t\tisUp,\n\t\t\tisDown,\n\t\t\tisLeftCtrl,\n\t\t\tisRightCtrl,\n\t\t\tisUpCtrl,\n\t\t\tisDownCtrl,\n\t\t\tisPlus,\n\t\t\tisMinus,\n\t\t\tisHome,\n\t\t\tisEnd,\n\t\t\tisPageUp,\n\t\t\tisPageDown,\n\t\t\tisEscape,\n\t\t];\n\t}\n\n\tstatic get MIN_SPACE_BETWEEN_TICKMARKS() {\n\t\treturn 8;\n\t}\n\n\tstatic get TOOLTIP_VISIBILITY() {\n\t\treturn {\n\t\t\tVISIBLE: \"visible\",\n\t\t\tHIDDEN: \"hidden\",\n\t\t};\n\t}\n\n\tget classes() {\n\t\treturn {\n\t\t\troot: {\n\t\t\t\t\"ui5-slider-root-phone\": isPhone(),\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"ui5-slider-hidden-labels\": this._labelsOverlapping,\n\t\t\t},\n\t\t};\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._resizeHandler);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._handleResize);\n\t}\n\n\tonAfterRendering() {\n\t\t// Only call if the resize is triggered by a state changes other than\n\t\t// the ones that occured on the previous resize and those caused by user interaction.\n\t\tif (this.notResized) {\n\t\t\tthis._resizeHandler();\n\t\t}\n\t}\n\n\t/** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseover(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseout(event) {\n\t\tif (this.showTooltip && !this.shadowRoot.activeElement) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t * Sets initial value when the component is focused in, can be restored with ESC key\n\t *\n\t * @private\n\t */\n\t_setInitialValue(valueType, value) {\n\t\tthis[`_${valueType}Initial`] = value;\n\t}\n\n\t_getInitialValue(valueType) {\n\t\treturn this[`_${valueType}Initial`];\n\t}\n\n\t_onkeydown(event) {\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (SliderBase._isActionKey(event)) {\n\t\t\tevent.preventDefault();\n\n\t\t\tthis._isUserInteraction = true;\n\t\t\tthis._handleActionKeyPress(event);\n\t\t}\n\t}\n\n\t_onkeyup(event) {\n\t\tif (this.disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isUserInteraction = false;\n\t}\n\n\t/**\n\t * Flags if an inner element is currently being focused\n\t *\n\t * @private\n\t */\n\t_preserveFocus(isFocusing) {\n\t\tthis._isInnerElementFocusing = isFocusing;\n\t}\n\n\t/**\n\t * Return if an inside element within the component is currently being focused\n\t *\n\t * @private\n\t */\n\t_isFocusing() {\n\t\treturn this._isInnerElementFocusing;\n\t}\n\n\t/**\n\t * Prevent focus out when inner element within the component is currently being in process of focusing in.\n\t * In theory this can be achieved either if the shadow root is focusable and 'delegatesFocus' attribute of\n\t * the .attachShadow() customElement method is set to true, or if we forward it manually.\n\n\t * As we use lit-element as base of our core UI5 element class that 'delegatesFocus' property is not set to 'true' and\n\t * we have to manage the focus here. If at some point in the future this changes, the focus delegating logic could be\n\t * removed as it will become redundant.\n\t *\n\t * When we manually set the focus on mouseDown to the first focusable element inside the shadowDom,\n\t * that inner focus (shadowRoot.activeElement) is set a moment before the global document.activeElement\n\t * is set to the customElement (ui5-slider) causing a 'race condition'.\n\t *\n\t * In order for a element within the shadowRoot to be focused, the global document.activeElement MUST be the parent\n\t * customElement of the shadow root, in our case the ui5-slider component. Because of that after our focusin of the handle,\n\t * a focusout event fired by the browser immidiatly after, resetting the focus. Focus out must be manually prevented\n\t * in both initial focusing and switching the focus between inner elements of the component cases.\n\n\t * Note: If we set the focus to the handle with a timeout or a bit later in time, on a mouseup or click event it will\n\t * work fine and we will avoid the described race condition as our host customElement will be already finished focusing.\n\t * However, that does not work for us as we need the focus to be set to the handle exactly on mousedown,\n\t * because of the nature of the component and its available drag interactions.\n\t *\n\t * @private\n\t */\n\t_preventFocusOut() {\n\t\tthis.focusInnerElement();\n\t}\n\n\t/**\n\t * Manages the focus between the component's inner elements\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tthis.focus();\n\t}\n\n\t/**\n\t * Handle the responsiveness of the Slider's UI elements when resizing\n\t *\n\t * @private\n\t */\n\t_handleResize() {\n\t\tif (!this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Mark resizing to avoid unneccessary calls to that function after rendering\n\t\tthis.notResized = false;\n\n\t\t// Convert the string represented calculation expression to a normal one\n\t\t// Check the distance  in pixels exist between every tickmark\n\t\tconst spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n\t\t// If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n\t\t// In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\t\tif (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n\t\t\tthis._hiddenTickmarks = true;\n\t\t\tthis._labelsOverlapping = true;\n\t\t} else {\n\t\t\tthis._hiddenTickmarks = false;\n\t\t}\n\n\t\tif (this.labelInterval <= 0 || this._hiddenTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if there are any overlapping labels.\n\t\t// If so - only the first and the last one should be visible\n\t\tconst labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n\t\tthis._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider.\n\t * After a down event on the slider root, listen for move events on window, so the slider value\n\t * is updated even if the user drags the pointer outside the slider root.\n\t *\n\t * @protected\n\t */\n\thandleDownBase(event) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst domRect = this.getBoundingClientRect();\n\t\tconst directionStart = this.directionStart;\n\t\tconst step = this._effectiveStep;\n\t\tconst newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n\n\t\t// Mark start of a user interaction\n\t\tthis._isUserInteraction = true;\n\t\t// Only allow one type of move event to be listened to (the first one registered after the down event)\n\t\tthis._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n\t\twindow.addEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._handleFocusOnMouseDown(event);\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Forward the focus to an inner inner part within the component on press\n\t *\n\t * @private\n\t */\n\t_handleFocusOnMouseDown(event) {\n\t\tconst focusedElement = this.shadowRoot.activeElement;\n\n\t\tif (!focusedElement || focusedElement !== event.target) {\n\t\t\tthis._preserveFocus(true);\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user finish interacting with the slider\n\t * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n\t *\n\t * @protected\n\t */\n\thandleUpBase(valueType) {\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n\t\twindow.removeEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._moveEventType = null;\n\t\tthis._isUserInteraction = false;\n\t\tthis._preserveFocus(false);\n\t}\n\n\t/**\n\t * Updates value property of the component that has been changed due to a user action.\n\t * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n\t *\n\t * @protected\n\t */\n\tupdateValue(valueType, value) {\n\t\tthis[valueType] = value;\n\t\tthis.storePropertyState(valueType);\n\t\tif (this._isUserInteraction) {\n\t\t\tthis.fireEvent(\"input\");\n\t\t}\n\t}\n\n\t/**\n\t * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n\t *\n\t * @private\n\t */\n\tstatic _isActionKey(event) {\n\t\treturn this.ACTION_KEYS.some(actionKey => actionKey(event));\n\t}\n\n\t/**\n\t * Locks the given value between min and max boundaries based on slider properties\n\t *\n\t * @protected\n\t */\n\tstatic clipValue(value, min, max) {\n\t\tvalue = Math.min(Math.max(value, min), max);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Sets the slider value from an event\n\t *\n\t * @protected\n\t */\n\tstatic getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n\t\tconst pageX = this.getPageXValueFromEvent(event);\n\t\tconst value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n\t\tconst steppedValue = this.getSteppedValue(value, stepSize, min);\n\n\t\treturn this.clipValue(steppedValue, min, max);\n\t}\n\n\t/**\n\t * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n\t *\n\t * @protected\n\t */\n\tstatic getSteppedValue(value, stepSize, min) {\n\t\tconst stepModuloValue = Math.abs((value - min) % stepSize);\n\n\t\tif (stepSize === 0 || stepModuloValue === 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// Clip (snap) the new value to the nearest step\n\t\tvalue = (stepModuloValue * 2 >= stepSize) ? (value + stepSize) - stepModuloValue : value - stepModuloValue;\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\t\treturn value.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Gets pageX value from event on user interaction with the Slider\n\t *\n\t * @protected\n\t */\n\tstatic getPageXValueFromEvent(event) {\n\t\tif (event.targetTouches && event.targetTouches.length > 0) {\n\t\t\treturn event.targetTouches[0].pageX;\n\t\t}\n\n\t\treturn event.pageX;\n\t}\n\n\t/**\n\t * Computes the new value (in %) from the pageX position of the cursor.\n\t * Returns the value rounded to a precision of at most 2 digits after decimal point.\n\t *\n\t * @protected\n\t */\n\tstatic computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n\t\t// Determine pageX position relative to the Slider DOM\n\t\tconst xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n\t\t// Calculate the percentage complete (the \"progress\")\n\t\tconst percentageComplete = xRelativePosition / boundingClientRect.width;\n\t\t// Fit (map) the complete percentage between the min/max value range\n\t\treturn min + percentageComplete * (max - min);\n\t}\n\n\t/**\n\t * Calculates the precision (decimal places) of a number, returns 0 if integer\n\t * Handles scientific notation cases.\n\t * @private\n\t */\n\tstatic _getDecimalPrecisionOfNumber(value) {\n\t\tif (Number.isInteger(value)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst match = (String(value)).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\treturn Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n\t}\n\n\t/**\n\t * Normalize current properties, update the previously stored state.\n\t *\n\t * @protected\n\t */\n\tsyncUIAndState(...values) {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programmatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tvalues.forEach(valueType => {\n\t\t\t\tconst normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n\t\t\t\tthis.updateValue(valueType, normalizedValue);\n\t\t\t\tthis.storePropertyState(valueType);\n\t\t\t});\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t/**\n\t * In order to always keep the visual UI representation and the internal\n\t * state in sync, the component has a 'state storage' that is updated when the\n\t * current state is changed due to a user action.\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * a property has been changed programmatically because the previous state\n\t * is always updated in the interaction handlers.\n\t *\n\t * Will return true if any of the properties is not equal to its previously\n\t * stored value.\n\t *\n\t * @protected\n\t */\n\tisCurrentStateOutdated() {\n\t\treturn Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n\t}\n\n\t/**\n\t * Returns the last stored value of a property\n\t *\n\t * @protected\n\t */\n\tgetStoredPropertyState(property) {\n\t\treturn this._stateStorage[property];\n\t}\n\n\t/**\n\t * Check if one or more properties have been updated compared to their last\n\t * saved values in the state storage.\n\t *\n\t * @protected\n\t */\n\tisPropertyUpdated(...properties) {\n\t\treturn properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n\t}\n\n\t/**\n\t * Updates the previously saved in the _stateStorage values of one or more properties.\n\t *\n\t * @protected\n\t */\n\tstorePropertyState(...props) {\n\t\tprops.forEach(property => {\n\t\t\tthis._stateStorage[property] = this[property];\n\t\t});\n\t}\n\n\t/**\n\t * Returns the start side of a direction - left for LTR, right for RTL\n\t */\n\tget directionStart() {\n\t\treturn this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n\t}\n\n\t/**\n\t * Calculates the labels amout, width and text and creates them\n\t *\n\t * @private\n\t */\n\t_createLabels() {\n\t\tif (!this.labelInterval || !this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelInterval = this.labelInterval;\n\t\tconst step = this._effectiveStep;\n\t\tconst newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n\t\t// If the required labels are already rendered\n\t\tif (newNumberOfLabels === this._oldNumberOfLabels) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._oldNumberOfLabels = newNumberOfLabels;\n\t\tthis._labelWidth = 100 / newNumberOfLabels;\n\t\tthis._labelValues = [];\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n\t\t// numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n\t\t// calculation to be precize (exactly the same as the distance between the tickmarks).\n\t\t// That's ok as the loop stop condition is set to an integer, so it will practically\n\t\t// \"floor\" the number of labels anyway.\n\t\tfor (let i = 0; i <= newNumberOfLabels; i++) {\n\t\t\t// Format the label numbers with the same decimal precision as the value of the step property\n\t\t\tconst labelItemNumber = ((i * step * labelInterval) + this._effectiveMin).toFixed(stepPrecision);\n\t\t\tthis._labelValues.push(labelItemNumber);\n\t\t}\n\t}\n\n\t_handleActionKeyPressBase(event, affectedValue) {\n\t\tconst isUpAction = SliderBase._isIncreaseValueAction(event);\n\t\tconst isBigStep = SliderBase._isBigStepAction(event);\n\n\t\tconst currentValue = this[affectedValue];\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\n\t\t// We need to take into consideration the effective direction of the slider - rtl or ltr.\n\t\t// While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n\t\tlet step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep;\n\n\t\t// If the action key corresponds to a long step and the slider has more than 10 normal steps,\n\t\t// make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n\t\tstep = isBigStep && ((max - min) / step > 10) ? (max - min) / 10 : step;\n\n\t\tif (isEnd(event)) {\n\t\t\treturn max - currentValue;\n\t\t}\n\n\t\tif (isHome(event)) {\n\t\t\treturn (currentValue - min) * -1;\n\t\t}\n\n\t\treturn isUpAction ? step : step * -1;\n\t}\n\n\tstatic _isDecreaseValueAction(event) {\n\t\treturn isDown(event) || isDownCtrl(event) || isLeft(event) || isLeftCtrl(event) || isMinus(event) || isPageDown(event);\n\t}\n\n\tstatic _isIncreaseValueAction(event) {\n\t\treturn isUp(event) || isUpCtrl(event) || isRight(event) || isRightCtrl(event) || isPlus(event) || isPageUp(event);\n\t}\n\n\tstatic _isBigStepAction(event) {\n\t\treturn isDownCtrl(event) || isUpCtrl(event) || isLeftCtrl(event) || isRightCtrl(event) || isPageUp(event) || isPageDown(event);\n\t}\n\n\tget _tickmarksCount() {\n\t\treturn (this._effectiveMax - this._effectiveMin) / this._effectiveStep;\n\t}\n\n\t/**\n\t * Calculates space between tickmarks\n\t *\n\t * @private\n\t */\n\t_spaceBetweenTickmarks() {\n\t\treturn this.getBoundingClientRect().width / this._tickmarksCount;\n\t}\n\n\t/**\n\t * Notify in case of a invalid step value type\n\t *\n\t * @private\n\t */\n\t_validateStep(step) {\n\t\tif (step === 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n\t\t}\n\n\t\tif (step < 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n\t\t}\n\t}\n\n\tget _labels() {\n\t\treturn this._labelValues || [];\n\t}\n\n\t/**\n\t * Normalizes a new <code>step</code> property value.\n\t * If tickmarks are enabled recreates them according to it.\n\t *\n\t * @private\n\t */\n\tget _effectiveStep() {\n\t\tlet step = this.step;\n\n\t\tif (step < 0) {\n\t\t\tstep = Math.abs(step);\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tstep = 1;\n\t\t}\n\n\t\treturn step;\n\t}\n\n\tget _effectiveMin() {\n\t\treturn Math.min(this.min, this.max);\n\t}\n\n\tget _effectiveMax() {\n\t\treturn Math.max(this.min, this.max);\n\t}\n\n\tget tabIndex() {\n\t\treturn this.disabled ? \"-1\" : \"0\";\n\t}\n\n\tget _ariaLabelledByHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n\t}\n}\n\nexport default SliderBase;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}