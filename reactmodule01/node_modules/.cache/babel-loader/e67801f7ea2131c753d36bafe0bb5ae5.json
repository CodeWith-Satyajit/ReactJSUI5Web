{"ast":null,"code":"import { isDown, isUp, isLeft, isRight, isHome, isEnd, isPageDown, isPageUp } from \"../Keys.js\";\nimport getActiveElement from \"../util/getActiveElement.js\";\nimport NavigationMode from \"../types/NavigationMode.js\";\nimport ItemNavigationBehavior from \"../types/ItemNavigationBehavior.js\";\n\n/**\n * The ItemNavigation class manages the calculations to determine the correct \"tabindex\" for a group of related items inside a root component.\n * Important: ItemNavigation only does the calculations and does not change \"tabindex\" directly, this is a responsibility of the developer.\n *\n * The keys that trigger ItemNavigation are:\n *  - Up/down\n *  - Left/right\n *  - Home/End\n *\n * Usage:\n * 1) Use the \"getItemsCallback\" constructor property to pass a callback to ItemNavigation, which, whenever called, will return the list of items to navigate among.\n *\n * Each item passed to ItemNavigation via \"getItemsCallback\" must be:\n *  - A) either a UI5Element with a \"_tabIndex\" property\n *  - B) or an Object with \"id\" and \"_tabIndex\" properties which represents a part of the root component's shadow DOM.\n *    The \"id\" must be a valid ID within the shadow root of the component ItemNavigation operates on.\n *    This object must not be a DOM object because, as said, ItemNavigation will not set \"tabindex\" on it. It must be a representation of a DOM object only\n *    and the developer has the responsibility to update the \"tabindex\" in the component's DOM.\n *  - C) a combination of the above\n *\n * Whenever the user navigates with the keyboard, ItemNavigation will modify the \"_tabIndex\" properties of the items.\n * It is the items' responsibilities to re-render themselves and apply the correct value of \"tabindex\" (i.e. to map the \"_tabIndex\" ItemNavigation set to them to the \"tabindex\" property).\n * If the items of the ItemNavigation are UI5Elements themselves, this can happen naturally since they will be invalidated by their \"_tabIndex\" property.\n * If the items are Objects with \"id\" and \"_tabIndex\" however, it is the developer's responsibility to apply these and the easiest way is to have the root component invalidated by ItemNavigation.\n * To do so, set the \"affectedPropertiesNames\" constructor property to point to one or more of the root component's properties that need refreshing when \"_tabIndex\" is changed deeply.\n *\n * 2) Call the \"setCurrentItem\" method of ItemNavigation whenever you want to change the current item.\n * This is most commonly required if the user for example clicks on an item and thus selects it directly.\n * Pass as the only argument to \"setCurrentItem\" the item that becomes current (must be one of the items, returned by \"getItemsCallback\").\n *\n * @class\n * @public\n */\nclass ItemNavigation {\n  /**\n   *\n   * @param rootWebComponent the component to operate on (component that slots or contains within its shadow root the items the user navigates among)\n   * @param options Object with configuration options:\n   *  - currentIndex: the index of the item that will be initially selected (from which navigation will begin)\n   *  - navigationMode (Auto|Horizontal|Vertical): whether the items are displayed horizontally (Horizontal), vertically (Vertical) or as a matrix (Auto) meaning the user can navigate in both directions (up/down and left/right)\n   *  - rowSize: tells how many items per row there are when the items are not rendered as a flat list but rather as a matrix. Relevant for navigationMode=Auto\n   * \t- skipItemsSize: tells how many items upon PAGE_UP and PAGE_DOWN should be skipped to applying the focus on the next item\n   *  - behavior (Static|Cycling): tells what to do when trying to navigate beyond the first and last items\n   *    Static means that nothing happens if the user tries to navigate beyond the first/last item.\n   *    Cycling means that when the user navigates beyond the last item they go to the first and vice versa.\n   *  - getItemsCallback: function that, when called, returns an array with all items the user can navigate among\n   *  - affectedPropertiesNames: a list of metadata properties on the root component which, upon user navigation, will be reassigned by address thus causing the root component to invalidate\n   */\n  constructor(rootWebComponent) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._setRootComponent(rootWebComponent);\n    this._initOptions(options);\n  }\n  _setRootComponent(rootWebComponent) {\n    if (!rootWebComponent.isUI5Element) {\n      throw new Error(\"The root web component must be a UI5 Element instance\");\n    }\n    this.rootWebComponent = rootWebComponent;\n    this.rootWebComponent.addEventListener(\"keydown\", this._onkeydown.bind(this));\n    this.rootWebComponent._onComponentStateFinalized = () => {\n      this._init();\n    };\n  }\n  _initOptions(options) {\n    if (typeof options.getItemsCallback !== \"function\") {\n      throw new Error(\"getItemsCallback is required\");\n    }\n    this._getItems = options.getItemsCallback;\n    this._currentIndex = options.currentIndex || 0;\n    this._rowSize = options.rowSize || 1;\n    this._behavior = options.behavior || ItemNavigationBehavior.Static;\n    this._navigationMode = options.navigationMode || NavigationMode.Auto;\n    this._affectedPropertiesNames = options.affectedPropertiesNames || [];\n    this._skipItemsSize = options.skipItemsSize || null;\n  }\n\n  /**\n   * Call this method to set a new \"current\" (selected) item in the item navigation\n   * Note: the item passed to this function must be one of the items, returned by the getItemsCallback function\n   *\n   * @public\n   * @param current the new selected item\n   */\n  setCurrentItem(current) {\n    const currentItemIndex = this._getItems().indexOf(current);\n    if (currentItemIndex === -1) {\n      console.warn(`The provided item is not managed by ItemNavigation`, current); // eslint-disable-line\n      return;\n    }\n    this._currentIndex = currentItemIndex;\n    this._applyTabIndex();\n  }\n\n  /**\n   * Call this method to dynamically change the row size\n   *\n   * @public\n   * @param newRowSize\n   */\n  setRowSize(newRowSize) {\n    this._rowSize = newRowSize;\n  }\n  _init() {\n    this._getItems().forEach((item, idx) => {\n      item._tabIndex = idx === this._currentIndex ? \"0\" : \"-1\";\n    });\n  }\n  _onkeydown(event) {\n    if (!this._canNavigate()) {\n      return;\n    }\n    const horizontalNavigationOn = this._navigationMode === NavigationMode.Horizontal || this._navigationMode === NavigationMode.Auto;\n    const verticalNavigationOn = this._navigationMode === NavigationMode.Vertical || this._navigationMode === NavigationMode.Auto;\n    const isRTL = this.rootWebComponent.effectiveDir === \"rtl\";\n    if (isRTL && isLeft(event) && horizontalNavigationOn) {\n      this._handleRight();\n    } else if (isRTL && isRight(event) && horizontalNavigationOn) {\n      this._handleLeft();\n    } else if (isLeft(event) && horizontalNavigationOn) {\n      this._handleLeft();\n    } else if (isRight(event) && horizontalNavigationOn) {\n      this._handleRight();\n    } else if (isUp(event) && verticalNavigationOn) {\n      this._handleUp();\n    } else if (isDown(event) && verticalNavigationOn) {\n      this._handleDown();\n    } else if (isHome(event)) {\n      this._handleHome();\n    } else if (isEnd(event)) {\n      this._handleEnd();\n    } else if (isPageUp(event)) {\n      this._handlePageUp();\n    } else if (isPageDown(event)) {\n      this._handlePageDown();\n    } else {\n      return; // if none of the supported keys is pressed, we don't want to prevent the event or update the item navigation\n    }\n\n    event.preventDefault();\n    this._applyTabIndex();\n    this._focusCurrentItem();\n  }\n  _handleUp() {\n    const itemsLength = this._getItems().length;\n    if (this._currentIndex - this._rowSize >= 0) {\n      // no border reached, just decrease the index by a row\n      this._currentIndex -= this._rowSize;\n      return;\n    }\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // if cyclic, go to the **last** item in the **previous** column\n      const firstItemInThisColumnIndex = this._currentIndex % this._rowSize;\n      const firstItemInPreviousColumnIndex = firstItemInThisColumnIndex === 0 ? this._rowSize - 1 : firstItemInThisColumnIndex - 1; // find the first item in the previous column (if the current column is the first column -> move to the last column)\n      const rows = Math.ceil(itemsLength / this._rowSize); // how many rows there are (even if incomplete, f.e. for 14 items and _rowSize=4 -> 4 rows total, although only 2 items on the last row)\n      let lastItemInPreviousColumnIndex = firstItemInPreviousColumnIndex + (rows - 1) * this._rowSize; // multiply rows by columns, and add the column's first item's index\n      if (lastItemInPreviousColumnIndex > itemsLength - 1) {\n        // for incomplete rows, use the previous row's last item, as for them the last item is missing\n        lastItemInPreviousColumnIndex -= this._rowSize;\n      }\n      this._currentIndex = lastItemInPreviousColumnIndex;\n    } else {\n      // not cyclic, so just go to the first item\n      this._currentIndex = 0;\n    }\n  }\n  _handleDown() {\n    const itemsLength = this._getItems().length;\n    if (this._currentIndex + this._rowSize < itemsLength) {\n      // no border reached, just increase the index by a row\n      this._currentIndex += this._rowSize;\n      return;\n    }\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // if cyclic, go to the **first** item in the **next** column\n      const firstItemInThisColumnIndex = this._currentIndex % this._rowSize; // find the first item in the current column first\n      const firstItemInNextColumnIndex = (firstItemInThisColumnIndex + 1) % this._rowSize; // to get the first item in the next column, just increase the index by 1. The modulo by rows is for the case when we are at the last column\n      this._currentIndex = firstItemInNextColumnIndex;\n    } else {\n      // not cyclic, so just go to the last item\n      this._currentIndex = itemsLength - 1;\n    }\n  }\n  _handleLeft() {\n    const itemsLength = this._getItems().length;\n    if (this._currentIndex > 0) {\n      this._currentIndex -= 1;\n      return;\n    }\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // go to the first item in the next column\n      this._currentIndex = itemsLength - 1;\n    }\n  }\n  _handleRight() {\n    const itemsLength = this._getItems().length;\n    if (this._currentIndex < itemsLength - 1) {\n      this._currentIndex += 1;\n      return;\n    }\n    if (this._behavior === ItemNavigationBehavior.Cyclic) {\n      // go to the first item in the next column\n      this._currentIndex = 0;\n    }\n  }\n  _handleHome() {\n    const homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n    this._currentIndex -= this._currentIndex % homeEndRange;\n  }\n  _handleEnd() {\n    const homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n    this._currentIndex += homeEndRange - 1 - this._currentIndex % homeEndRange; // eslint-disable-line\n  }\n\n  _handlePageUp() {\n    if (this._rowSize > 1) {\n      // eslint-disable-next-line\n      // TODO: handle page up on matrix (grid) layout - ColorPalette, ProductSwitch.\n      return;\n    }\n    this._handlePageUpFlat();\n  }\n  _handlePageDown() {\n    if (this._rowSize > 1) {\n      // eslint-disable-next-line\n      // TODO: handle page up on matrix (grid) layout - ColorPalette, ProductSwitch.\n      return;\n    }\n    this._handlePageDownFlat();\n  }\n\n  /**\n   * Handles PAGE_UP in a flat list-like structure, both vertically and horizontally.\n   */\n  _handlePageUpFlat() {\n    if (this._skipItemsSize === null) {\n      // Move the focus to the very top (as Home).\n      this._currentIndex -= this._currentIndex;\n    }\n    if (this._currentIndex + 1 > this._skipItemsSize) {\n      // When there are more than \"skipItemsSize\" number of items to the top,\n      // move the focus up/left with the predefined number.\n      this._currentIndex -= this._skipItemsSize;\n    } else {\n      // Otherwise, move the focus to the very top (as Home).\n      this._currentIndex -= this._currentIndex;\n    }\n  }\n\n  /**\n   * Handles PAGE_DOWN in a flat list-like structure, both vertically and horizontally.\n   */\n  _handlePageDownFlat() {\n    if (this._skipItemsSize === null) {\n      // Move the focus to the very bottom (as End).\n      this._currentIndex = this._getItems().length - 1;\n    }\n    const currentToEndRange = this._getItems().length - this._currentIndex - 1;\n    if (currentToEndRange > this._skipItemsSize) {\n      // When there are more than \"skipItemsSize\" number of items until the bottom,\n      // move the focus down/right with the predefined number.\n      this._currentIndex += this._skipItemsSize;\n    } else {\n      // Otherwise, move the focus to the very bottom (as End).\n      this._currentIndex = this._getItems().length - 1;\n    }\n  }\n  _applyTabIndex() {\n    const items = this._getItems();\n    for (let i = 0; i < items.length; i++) {\n      items[i]._tabIndex = i === this._currentIndex ? \"0\" : \"-1\";\n    }\n    this._affectedPropertiesNames.forEach(propName => {\n      const prop = this.rootWebComponent[propName];\n      this.rootWebComponent[propName] = Array.isArray(prop) ? [...prop] : {\n        ...prop\n      };\n    });\n  }\n  _focusCurrentItem() {\n    const currentItem = this._getCurrentItem();\n    if (currentItem) {\n      currentItem.focus();\n    }\n  }\n  _canNavigate() {\n    const currentItem = this._getCurrentItem();\n    const activeElement = getActiveElement();\n    return currentItem && currentItem === activeElement;\n  }\n  _getCurrentItem() {\n    const items = this._getItems();\n    if (!items.length) {\n      return null;\n    }\n\n    // normalize the index\n    while (this._currentIndex >= items.length) {\n      this._currentIndex -= this._rowSize;\n    }\n    if (this._currentIndex < 0) {\n      this._currentIndex = 0;\n    }\n    const currentItem = items[this._currentIndex];\n    if (!currentItem) {\n      return;\n    }\n    if (currentItem.isUI5Element) {\n      return currentItem.getFocusDomRef();\n    }\n    if (!this.rootWebComponent.getDomRef()) {\n      return;\n    }\n    return this.rootWebComponent.getDomRef().querySelector(`#${currentItem.id}`);\n  }\n}\nexport default ItemNavigation;","map":{"version":3,"names":["isDown","isUp","isLeft","isRight","isHome","isEnd","isPageDown","isPageUp","getActiveElement","NavigationMode","ItemNavigationBehavior","ItemNavigation","constructor","rootWebComponent","options","_setRootComponent","_initOptions","isUI5Element","Error","addEventListener","_onkeydown","bind","_onComponentStateFinalized","_init","getItemsCallback","_getItems","_currentIndex","currentIndex","_rowSize","rowSize","_behavior","behavior","Static","_navigationMode","navigationMode","Auto","_affectedPropertiesNames","affectedPropertiesNames","_skipItemsSize","skipItemsSize","setCurrentItem","current","currentItemIndex","indexOf","console","warn","_applyTabIndex","setRowSize","newRowSize","forEach","item","idx","_tabIndex","event","_canNavigate","horizontalNavigationOn","Horizontal","verticalNavigationOn","Vertical","isRTL","effectiveDir","_handleRight","_handleLeft","_handleUp","_handleDown","_handleHome","_handleEnd","_handlePageUp","_handlePageDown","preventDefault","_focusCurrentItem","itemsLength","length","Cyclic","firstItemInThisColumnIndex","firstItemInPreviousColumnIndex","rows","Math","ceil","lastItemInPreviousColumnIndex","firstItemInNextColumnIndex","homeEndRange","_handlePageUpFlat","_handlePageDownFlat","currentToEndRange","items","i","propName","prop","Array","isArray","currentItem","_getCurrentItem","focus","activeElement","getFocusDomRef","getDomRef","querySelector","id"],"sources":["/home/user/projects/reactwithcap01/reactmodule01/node_modules/@ui5/webcomponents-base/dist/delegate/ItemNavigation.js"],"sourcesContent":["import {\n\tisDown,\n\tisUp,\n\tisLeft,\n\tisRight,\n\tisHome,\n\tisEnd,\n\tisPageDown,\n\tisPageUp,\n} from \"../Keys.js\";\nimport getActiveElement from \"../util/getActiveElement.js\";\n\nimport NavigationMode from \"../types/NavigationMode.js\";\nimport ItemNavigationBehavior from \"../types/ItemNavigationBehavior.js\";\n\n/**\n * The ItemNavigation class manages the calculations to determine the correct \"tabindex\" for a group of related items inside a root component.\n * Important: ItemNavigation only does the calculations and does not change \"tabindex\" directly, this is a responsibility of the developer.\n *\n * The keys that trigger ItemNavigation are:\n *  - Up/down\n *  - Left/right\n *  - Home/End\n *\n * Usage:\n * 1) Use the \"getItemsCallback\" constructor property to pass a callback to ItemNavigation, which, whenever called, will return the list of items to navigate among.\n *\n * Each item passed to ItemNavigation via \"getItemsCallback\" must be:\n *  - A) either a UI5Element with a \"_tabIndex\" property\n *  - B) or an Object with \"id\" and \"_tabIndex\" properties which represents a part of the root component's shadow DOM.\n *    The \"id\" must be a valid ID within the shadow root of the component ItemNavigation operates on.\n *    This object must not be a DOM object because, as said, ItemNavigation will not set \"tabindex\" on it. It must be a representation of a DOM object only\n *    and the developer has the responsibility to update the \"tabindex\" in the component's DOM.\n *  - C) a combination of the above\n *\n * Whenever the user navigates with the keyboard, ItemNavigation will modify the \"_tabIndex\" properties of the items.\n * It is the items' responsibilities to re-render themselves and apply the correct value of \"tabindex\" (i.e. to map the \"_tabIndex\" ItemNavigation set to them to the \"tabindex\" property).\n * If the items of the ItemNavigation are UI5Elements themselves, this can happen naturally since they will be invalidated by their \"_tabIndex\" property.\n * If the items are Objects with \"id\" and \"_tabIndex\" however, it is the developer's responsibility to apply these and the easiest way is to have the root component invalidated by ItemNavigation.\n * To do so, set the \"affectedPropertiesNames\" constructor property to point to one or more of the root component's properties that need refreshing when \"_tabIndex\" is changed deeply.\n *\n * 2) Call the \"setCurrentItem\" method of ItemNavigation whenever you want to change the current item.\n * This is most commonly required if the user for example clicks on an item and thus selects it directly.\n * Pass as the only argument to \"setCurrentItem\" the item that becomes current (must be one of the items, returned by \"getItemsCallback\").\n *\n * @class\n * @public\n */\nclass ItemNavigation {\n\t/**\n\t *\n\t * @param rootWebComponent the component to operate on (component that slots or contains within its shadow root the items the user navigates among)\n\t * @param options Object with configuration options:\n\t *  - currentIndex: the index of the item that will be initially selected (from which navigation will begin)\n\t *  - navigationMode (Auto|Horizontal|Vertical): whether the items are displayed horizontally (Horizontal), vertically (Vertical) or as a matrix (Auto) meaning the user can navigate in both directions (up/down and left/right)\n\t *  - rowSize: tells how many items per row there are when the items are not rendered as a flat list but rather as a matrix. Relevant for navigationMode=Auto\n\t * \t- skipItemsSize: tells how many items upon PAGE_UP and PAGE_DOWN should be skipped to applying the focus on the next item\n\t *  - behavior (Static|Cycling): tells what to do when trying to navigate beyond the first and last items\n\t *    Static means that nothing happens if the user tries to navigate beyond the first/last item.\n\t *    Cycling means that when the user navigates beyond the last item they go to the first and vice versa.\n\t *  - getItemsCallback: function that, when called, returns an array with all items the user can navigate among\n\t *  - affectedPropertiesNames: a list of metadata properties on the root component which, upon user navigation, will be reassigned by address thus causing the root component to invalidate\n\t */\n\tconstructor(rootWebComponent, options = {}) {\n\t\tthis._setRootComponent(rootWebComponent);\n\t\tthis._initOptions(options);\n\t}\n\n\t_setRootComponent(rootWebComponent) {\n\t\tif (!rootWebComponent.isUI5Element) {\n\t\t\tthrow new Error(\"The root web component must be a UI5 Element instance\");\n\t\t}\n\t\tthis.rootWebComponent = rootWebComponent;\n\t\tthis.rootWebComponent.addEventListener(\"keydown\", this._onkeydown.bind(this));\n\t\tthis.rootWebComponent._onComponentStateFinalized = () => {\n\t\t\tthis._init();\n\t\t};\n\t}\n\n\t_initOptions(options) {\n\t\tif (typeof options.getItemsCallback !== \"function\") {\n\t\t\tthrow new Error(\"getItemsCallback is required\");\n\t\t}\n\n\t\tthis._getItems = options.getItemsCallback;\n\t\tthis._currentIndex = options.currentIndex || 0;\n\t\tthis._rowSize = options.rowSize || 1;\n\t\tthis._behavior = options.behavior || ItemNavigationBehavior.Static;\n\t\tthis._navigationMode = options.navigationMode || NavigationMode.Auto;\n\t\tthis._affectedPropertiesNames = options.affectedPropertiesNames || [];\n\t\tthis._skipItemsSize = options.skipItemsSize || null;\n\t}\n\n\t/**\n\t * Call this method to set a new \"current\" (selected) item in the item navigation\n\t * Note: the item passed to this function must be one of the items, returned by the getItemsCallback function\n\t *\n\t * @public\n\t * @param current the new selected item\n\t */\n\tsetCurrentItem(current) {\n\t\tconst currentItemIndex = this._getItems().indexOf(current);\n\n\t\tif (currentItemIndex === -1) {\n\t\t\tconsole.warn(`The provided item is not managed by ItemNavigation`, current); // eslint-disable-line\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentIndex = currentItemIndex;\n\t\tthis._applyTabIndex();\n\t}\n\n\t/**\n\t * Call this method to dynamically change the row size\n\t *\n\t * @public\n\t * @param newRowSize\n\t */\n\tsetRowSize(newRowSize) {\n\t\tthis._rowSize = newRowSize;\n\t}\n\n\t_init() {\n\t\tthis._getItems().forEach((item, idx) => {\n\t\t\titem._tabIndex = (idx === this._currentIndex) ? \"0\" : \"-1\";\n\t\t});\n\t}\n\n\t_onkeydown(event) {\n\t\tif (!this._canNavigate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst horizontalNavigationOn = this._navigationMode === NavigationMode.Horizontal || this._navigationMode === NavigationMode.Auto;\n\t\tconst verticalNavigationOn = this._navigationMode === NavigationMode.Vertical || this._navigationMode === NavigationMode.Auto;\n\t\tconst isRTL = this.rootWebComponent.effectiveDir === \"rtl\";\n\n\t\tif (isRTL && isLeft(event) && horizontalNavigationOn) {\n\t\t\tthis._handleRight();\n\t\t} else if (isRTL && isRight(event) && horizontalNavigationOn) {\n\t\t\tthis._handleLeft();\n\t\t} else if (isLeft(event) && horizontalNavigationOn) {\n\t\t\tthis._handleLeft();\n\t\t} else if (isRight(event) && horizontalNavigationOn) {\n\t\t\tthis._handleRight();\n\t\t} else if (isUp(event) && verticalNavigationOn) {\n\t\t\tthis._handleUp();\n\t\t} else if (isDown(event) && verticalNavigationOn) {\n\t\t\tthis._handleDown();\n\t\t} else if (isHome(event)) {\n\t\t\tthis._handleHome();\n\t\t} else if (isEnd(event)) {\n\t\t\tthis._handleEnd();\n\t\t} else if (isPageUp(event)) {\n\t\t\tthis._handlePageUp();\n\t\t} else if (isPageDown(event)) {\n\t\t\tthis._handlePageDown();\n\t\t} else {\n\t\t\treturn; // if none of the supported keys is pressed, we don't want to prevent the event or update the item navigation\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tthis._applyTabIndex();\n\t\tthis._focusCurrentItem();\n\t}\n\n\t_handleUp() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex - this._rowSize >= 0) { // no border reached, just decrease the index by a row\n\t\t\tthis._currentIndex -= this._rowSize;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // if cyclic, go to the **last** item in the **previous** column\n\t\t\tconst firstItemInThisColumnIndex = this._currentIndex % this._rowSize;\n\t\t\tconst firstItemInPreviousColumnIndex = firstItemInThisColumnIndex === 0 ? this._rowSize - 1 : firstItemInThisColumnIndex - 1; // find the first item in the previous column (if the current column is the first column -> move to the last column)\n\t\t\tconst rows = Math.ceil(itemsLength / this._rowSize); // how many rows there are (even if incomplete, f.e. for 14 items and _rowSize=4 -> 4 rows total, although only 2 items on the last row)\n\t\t\tlet lastItemInPreviousColumnIndex = firstItemInPreviousColumnIndex + (rows - 1) * this._rowSize; // multiply rows by columns, and add the column's first item's index\n\t\t\tif (lastItemInPreviousColumnIndex > itemsLength - 1) { // for incomplete rows, use the previous row's last item, as for them the last item is missing\n\t\t\t\tlastItemInPreviousColumnIndex -= this._rowSize;\n\t\t\t}\n\t\t\tthis._currentIndex = lastItemInPreviousColumnIndex;\n\t\t} else { // not cyclic, so just go to the first item\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\t}\n\n\t_handleDown() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex + this._rowSize < itemsLength) { // no border reached, just increase the index by a row\n\t\t\tthis._currentIndex += this._rowSize;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // if cyclic, go to the **first** item in the **next** column\n\t\t\tconst firstItemInThisColumnIndex = this._currentIndex % this._rowSize; // find the first item in the current column first\n\t\t\tconst firstItemInNextColumnIndex = (firstItemInThisColumnIndex + 1) % this._rowSize; // to get the first item in the next column, just increase the index by 1. The modulo by rows is for the case when we are at the last column\n\t\t\tthis._currentIndex = firstItemInNextColumnIndex;\n\t\t} else { // not cyclic, so just go to the last item\n\t\t\tthis._currentIndex = itemsLength - 1;\n\t\t}\n\t}\n\n\t_handleLeft() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex > 0) {\n\t\t\tthis._currentIndex -= 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // go to the first item in the next column\n\t\t\tthis._currentIndex = itemsLength - 1;\n\t\t}\n\t}\n\n\t_handleRight() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex < itemsLength - 1) {\n\t\t\tthis._currentIndex += 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // go to the first item in the next column\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\t}\n\n\t_handleHome() {\n\t\tconst homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n\t\tthis._currentIndex -= this._currentIndex % homeEndRange;\n\t}\n\n\t_handleEnd() {\n\t\tconst homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n\t\tthis._currentIndex += (homeEndRange - 1 - this._currentIndex % homeEndRange); // eslint-disable-line\n\t}\n\n\t_handlePageUp() {\n\t\tif (this._rowSize > 1) {\n\t\t\t// eslint-disable-next-line\n\t\t\t// TODO: handle page up on matrix (grid) layout - ColorPalette, ProductSwitch.\n\t\t\treturn;\n\t\t}\n\t\tthis._handlePageUpFlat();\n\t}\n\n\t_handlePageDown() {\n\t\tif (this._rowSize > 1) {\n\t\t\t// eslint-disable-next-line\n\t\t\t// TODO: handle page up on matrix (grid) layout - ColorPalette, ProductSwitch.\n\t\t\treturn;\n\t\t}\n\t\tthis._handlePageDownFlat();\n\t}\n\n\t/**\n\t * Handles PAGE_UP in a flat list-like structure, both vertically and horizontally.\n\t */\n\t_handlePageUpFlat() {\n\t\tif (this._skipItemsSize === null) {\n\t\t\t// Move the focus to the very top (as Home).\n\t\t\tthis._currentIndex -= this._currentIndex;\n\t\t}\n\n\t\tif (this._currentIndex + 1 > this._skipItemsSize) {\n\t\t\t// When there are more than \"skipItemsSize\" number of items to the top,\n\t\t\t// move the focus up/left with the predefined number.\n\t\t\tthis._currentIndex -= this._skipItemsSize;\n\t\t} else {\n\t\t\t// Otherwise, move the focus to the very top (as Home).\n\t\t\tthis._currentIndex -= this._currentIndex;\n\t\t}\n\t}\n\n\t/**\n\t * Handles PAGE_DOWN in a flat list-like structure, both vertically and horizontally.\n\t */\n\t_handlePageDownFlat() {\n\t\tif (this._skipItemsSize === null) {\n\t\t\t// Move the focus to the very bottom (as End).\n\t\t\tthis._currentIndex = this._getItems().length - 1;\n\t\t}\n\n\t\tconst currentToEndRange = this._getItems().length - this._currentIndex - 1;\n\n\t\tif (currentToEndRange > this._skipItemsSize) {\n\t\t\t// When there are more than \"skipItemsSize\" number of items until the bottom,\n\t\t\t// move the focus down/right with the predefined number.\n\t\t\tthis._currentIndex += this._skipItemsSize;\n\t\t} else {\n\t\t\t// Otherwise, move the focus to the very bottom (as End).\n\t\t\tthis._currentIndex = this._getItems().length - 1;\n\t\t}\n\t}\n\n\t_applyTabIndex() {\n\t\tconst items = this._getItems();\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\titems[i]._tabIndex = i === this._currentIndex ? \"0\" : \"-1\";\n\t\t}\n\n\t\tthis._affectedPropertiesNames.forEach(propName => {\n\t\t\tconst prop = this.rootWebComponent[propName];\n\t\t\tthis.rootWebComponent[propName] = Array.isArray(prop) ? [...prop] : { ...prop };\n\t\t});\n\t}\n\n\t_focusCurrentItem() {\n\t\tconst currentItem = this._getCurrentItem();\n\t\tif (currentItem) {\n\t\t\tcurrentItem.focus();\n\t\t}\n\t}\n\n\t_canNavigate() {\n\t\tconst currentItem = this._getCurrentItem();\n\t\tconst activeElement = getActiveElement();\n\n\t\treturn currentItem && currentItem === activeElement;\n\t}\n\n\t_getCurrentItem() {\n\t\tconst items = this._getItems();\n\n\t\tif (!items.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// normalize the index\n\t\twhile (this._currentIndex >= items.length) {\n\t\t\tthis._currentIndex -= this._rowSize;\n\t\t}\n\n\t\tif (this._currentIndex < 0) {\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\n\t\tconst currentItem = items[this._currentIndex];\n\n\t\tif (!currentItem) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (currentItem.isUI5Element) {\n\t\t\treturn currentItem.getFocusDomRef();\n\t\t}\n\n\t\tif (!this.rootWebComponent.getDomRef()) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.rootWebComponent.getDomRef().querySelector(`#${currentItem.id}`);\n\t}\n}\n\nexport default ItemNavigation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}