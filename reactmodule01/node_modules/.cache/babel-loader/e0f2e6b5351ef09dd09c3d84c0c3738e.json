{"ast":null,"code":"/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports, require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\"], t) : t((e = \"undefined\" != typeof globalThis ? globalThis : e || self).ReactVirtual = {}, e.React);\n}(this, function (e, t) {\n  \"use strict\";\n\n  function s(e) {\n    if (e && e.__esModule) return e;\n    var t = Object.create(null);\n    return e && Object.keys(e).forEach(function (s) {\n      if (\"default\" !== s) {\n        var n = Object.getOwnPropertyDescriptor(e, s);\n        Object.defineProperty(t, s, n.get ? n : {\n          enumerable: !0,\n          get: function () {\n            return e[s];\n          }\n        });\n      }\n    }), t.default = e, Object.freeze(t);\n  }\n  var n = s(t);\n  /**\n     * virtual-core\n     *\n     * Copyright (c) TanStack\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE.md file in the root directory of this source tree.\n     *\n     * @license MIT\n     */\n  function o(e, t, s) {\n    let n,\n      o = [];\n    return () => {\n      let i;\n      s.key && null != s.debug && s.debug() && (i = Date.now());\n      const l = e();\n      if (!(l.length !== o.length || l.some((e, t) => o[t] !== e))) return n;\n      let r;\n      if (o = l, s.key && null != s.debug && s.debug() && (r = Date.now()), n = t(...l), null == s || null == s.onChange || s.onChange(n), s.key && null != s.debug && s.debug()) {\n        const e = Math.round(100 * (Date.now() - i)) / 100,\n          t = Math.round(100 * (Date.now() - r)) / 100,\n          n = t / 16,\n          o = (e, t) => {\n            for (e = String(e); e.length < t;) e = \" \" + e;\n            return e;\n          };\n        console.info(\"%c⏱ \" + o(t, 5) + \" /\" + o(e, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * n, 120)) + \"deg 100% 31%);\", null == s ? void 0 : s.key);\n      }\n      return n;\n    };\n  }\n  const i = e => e,\n    l = e => {\n      const t = Math.max(e.startIndex - e.overscan, 0),\n        s = Math.min(e.endIndex + e.overscan, e.count - 1),\n        n = [];\n      for (let e = t; e <= s; e++) n.push(e);\n      return n;\n    },\n    r = (e, t) => {\n      const s = new ResizeObserver(e => {\n        var s, n;\n        t({\n          width: null == (s = e[0]) ? void 0 : s.contentRect.width,\n          height: null == (n = e[0]) ? void 0 : n.contentRect.height\n        });\n      });\n      if (e.scrollElement) return t(e.scrollElement.getBoundingClientRect()), s.observe(e.scrollElement), () => {\n        s.unobserve(e.scrollElement);\n      };\n    },\n    c = (e, t) => {\n      const s = ((e, t) => {\n          let s = {\n            height: -1,\n            width: -1\n          };\n          return n => {\n            (e.options.horizontal ? n.width !== s.width : n.height !== s.height) && t(n), s = n;\n          };\n        })(e, t),\n        n = () => s({\n          width: e.scrollElement.innerWidth,\n          height: e.scrollElement.innerHeight\n        });\n      if (e.scrollElement) return n(), e.scrollElement.addEventListener(\"resize\", n, {\n        capture: !1,\n        passive: !0\n      }), () => {\n        e.scrollElement.removeEventListener(\"resize\", n);\n      };\n    },\n    a = {\n      element: [\"scrollLeft\", \"scrollTop\"],\n      window: [\"scrollX\", \"scrollY\"]\n    },\n    h = e => (t, s) => {\n      if (!t.scrollElement) return;\n      const n = a[e][0],\n        o = a[e][1];\n      let i = t.scrollElement[n],\n        l = t.scrollElement[o];\n      const r = () => {\n        s(t.scrollElement[t.options.horizontal ? n : o]);\n      };\n      r();\n      const c = e => {\n        const s = e.currentTarget,\n          c = s[n],\n          a = s[o];\n        (t.options.horizontal ? i - c : l - a) && r(), i = c, l = a;\n      };\n      return t.scrollElement.addEventListener(\"scroll\", c, {\n        capture: !1,\n        passive: !0\n      }), () => {\n        t.scrollElement.removeEventListener(\"scroll\", c);\n      };\n    },\n    u = h(\"element\"),\n    d = h(\"window\"),\n    f = (e, t) => e.getBoundingClientRect()[t.options.horizontal ? \"width\" : \"height\"],\n    m = (e, t, s) => {\n      var n;\n      null == (n = s.scrollElement) || null == n.scrollTo || n.scrollTo({\n        [s.options.horizontal ? \"left\" : \"top\"]: e,\n        behavior: t ? \"smooth\" : void 0\n      });\n    },\n    g = (e, t, s) => {\n      var n;\n      null == (n = s.scrollElement) || null == n.scrollTo || n.scrollTo({\n        [s.options.horizontal ? \"left\" : \"top\"]: e,\n        behavior: t ? \"smooth\" : void 0\n      });\n    };\n  class p {\n    constructor(e) {\n      var t = this;\n      this.unsubs = [], this.scrollElement = null, this.measurementsCache = [], this.itemMeasurementsCache = {}, this.pendingMeasuredCacheIndexes = [], this.measureElementCache = {}, this.range = {\n        startIndex: 0,\n        endIndex: 0\n      }, this.setOptions = e => {\n        Object.entries(e).forEach(t => {\n          let [s, n] = t;\n          void 0 === n && delete e[s];\n        }), this.options = {\n          debug: !1,\n          initialOffset: 0,\n          overscan: 1,\n          paddingStart: 0,\n          paddingEnd: 0,\n          scrollPaddingStart: 0,\n          scrollPaddingEnd: 0,\n          horizontal: !1,\n          getItemKey: i,\n          rangeExtractor: l,\n          enableSmoothScroll: !0,\n          onChange: () => {},\n          measureElement: f,\n          initialRect: {\n            width: 0,\n            height: 0\n          },\n          ...e\n        };\n      }, this.notify = () => {\n        var e, t;\n        null == (e = (t = this.options).onChange) || e.call(t, this);\n      }, this.cleanup = () => {\n        this.unsubs.filter(Boolean).forEach(e => e()), this.unsubs = [], this.scrollElement = null;\n      }, this._didMount = () => () => {\n        this.cleanup();\n      }, this._willUpdate = () => {\n        const e = this.options.getScrollElement();\n        this.scrollElement !== e && (this.cleanup(), this.scrollElement = e, this._scrollToOffset(this.scrollOffset, !1), this.unsubs.push(this.options.observeElementRect(this, e => {\n          this.scrollRect = e, this.calculateRange();\n        })), this.unsubs.push(this.options.observeElementOffset(this, e => {\n          this.scrollOffset = e, this.calculateRange();\n        })));\n      }, this.getSize = () => this.scrollRect[this.options.horizontal ? \"width\" : \"height\"], this.getMeasurements = o(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (e, t, s, n) => {\n        const o = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const i = this.measurementsCache.slice(0, o);\n        for (let l = o; l < e; l++) {\n          const e = s(l),\n            o = n[e],\n            r = i[l - 1] ? i[l - 1].end : t,\n            c = \"number\" == typeof o ? o : this.options.estimateSize(l),\n            a = r + c;\n          i[l] = {\n            index: l,\n            start: r,\n            size: c,\n            end: a,\n            key: e\n          };\n        }\n        return this.measurementsCache = i, i;\n      }, {\n        key: !1,\n        debug: () => this.options.debug\n      }), this.calculateRange = o(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (e, t, s) => {\n        const n = function (e) {\n          let {\n            measurements: t,\n            outerSize: s,\n            scrollOffset: n\n          } = e;\n          const o = t.length - 1,\n            i = ((e, t, s, n) => {\n              for (; e <= t;) {\n                const o = (e + t) / 2 | 0,\n                  i = s(o);\n                if (i < n) e = o + 1;else {\n                  if (!(i > n)) return o;\n                  t = o - 1;\n                }\n              }\n              return e > 0 ? e - 1 : 0;\n            })(0, o, e => t[e].start, n);\n          let l = i;\n          for (; l < o && t[l].end < n + s;) l++;\n          return {\n            startIndex: i,\n            endIndex: l\n          };\n        }({\n          measurements: e,\n          outerSize: t,\n          scrollOffset: s\n        });\n        return n.startIndex === this.range.startIndex && n.endIndex === this.range.endIndex || (this.range = n, this.notify()), this.range;\n      }, {\n        key: !1,\n        debug: () => this.options.debug\n      }), this.getIndexes = o(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (e, t, s, n) => e({\n        ...t,\n        overscan: s,\n        count: n\n      }), {\n        key: !1,\n        debug: () => this.options.debug\n      }), this.getVirtualItems = o(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (e, t, s) => {\n        const n = e => t => {\n            var n;\n            const o = this.measurementsCache[e];\n            if (!t) return;\n            const i = s(t, this),\n              l = null != (n = this.itemMeasurementsCache[o.key]) ? n : o.size;\n            i !== l && (o.start < this.scrollOffset && (this.destinationOffset || this._scrollToOffset(this.scrollOffset + (i - l), !1)), this.pendingMeasuredCacheIndexes.push(e), this.itemMeasurementsCache = {\n              ...this.itemMeasurementsCache,\n              [o.key]: i\n            }, this.notify());\n          },\n          o = [],\n          i = {};\n        for (let s = 0, r = e.length; s < r; s++) {\n          var l;\n          const r = e[s],\n            c = {\n              ...t[r],\n              measureElement: i[r] = null != (l = this.measureElementCache[r]) ? l : n(r)\n            };\n          o.push(c);\n        }\n        return this.measureElementCache = i, o;\n      }, {\n        key: !1,\n        debug: () => this.options.debug\n      }), this.scrollToOffset = function (e, s) {\n        let {\n          align: n = \"start\",\n          smoothScroll: o = t.options.enableSmoothScroll\n        } = void 0 === s ? {} : s;\n        const i = t.scrollOffset,\n          l = t.getSize();\n        \"auto\" === n && (n = e <= i ? \"start\" : e >= i + l ? \"end\" : \"start\"), \"start\" === n ? t._scrollToOffset(e, o) : \"end\" === n ? t._scrollToOffset(e - l, o) : \"center\" === n && t._scrollToOffset(e - l / 2, o);\n      }, this.scrollToIndex = function (e, s) {\n        let {\n          align: n = \"auto\",\n          smoothScroll: o = t.options.enableSmoothScroll,\n          ...i\n        } = void 0 === s ? {} : s;\n        const l = t.getMeasurements(),\n          r = t.scrollOffset,\n          c = t.getSize(),\n          {\n            count: a\n          } = t.options,\n          h = l[Math.max(0, Math.min(e, a - 1))];\n        if (!h) return;\n        if (\"auto\" === n) if (h.end >= r + c - t.options.scrollPaddingEnd) n = \"end\";else {\n          if (!(h.start <= r + t.options.scrollPaddingStart)) return;\n          n = \"start\";\n        }\n        const u = \"end\" === n ? h.end + t.options.scrollPaddingEnd : h.start - t.options.scrollPaddingStart;\n        t.scrollToOffset(u, {\n          align: n,\n          smoothScroll: o,\n          ...i\n        });\n      }, this.getTotalSize = () => {\n        var e;\n        return ((null == (e = this.getMeasurements()[this.options.count - 1]) ? void 0 : e.end) || this.options.paddingStart) + this.options.paddingEnd;\n      }, this._scrollToOffset = (e, t) => {\n        let s;\n        clearTimeout(this.scrollCheckFrame), this.destinationOffset = e, this.options.scrollToFn(e, t, this);\n        const n = () => {\n          let e = this.scrollOffset;\n          this.scrollCheckFrame = s = setTimeout(() => {\n            this.scrollCheckFrame === s && (this.scrollOffset !== e ? (e = this.scrollOffset, n()) : this.destinationOffset = void 0);\n          }, 100);\n        };\n        n();\n      }, this.measure = () => {\n        this.itemMeasurementsCache = {}, this.notify();\n      }, this.setOptions(e), this.scrollRect = this.options.initialRect, this.scrollOffset = this.options.initialOffset, this.calculateRange();\n    }\n  }\n  const E = \"undefined\" != typeof window ? n.useLayoutEffect : n.useEffect;\n  function b(e) {\n    const t = n.useReducer(() => ({}), {})[1],\n      s = {\n        ...e,\n        onChange: s => {\n          t(), null == e.onChange || e.onChange(s);\n        }\n      },\n      [o] = n.useState(() => new p(s));\n    return o.setOptions(s), n.useEffect(() => o._didMount(), []), E(() => o._willUpdate()), o;\n  }\n  e.Virtualizer = p, e.defaultKeyExtractor = i, e.defaultRangeExtractor = l, e.elementScroll = g, e.measureElement = f, e.memo = o, e.observeElementOffset = u, e.observeElementRect = r, e.observeWindowOffset = d, e.observeWindowRect = c, e.useVirtualizer = function (e) {\n    return b({\n      observeElementRect: r,\n      observeElementOffset: u,\n      scrollToFn: g,\n      ...e\n    });\n  }, e.useWindowVirtualizer = function (e) {\n    return b({\n      getScrollElement: () => \"undefined\" != typeof window ? window : null,\n      observeElementRect: c,\n      observeElementOffset: d,\n      scrollToFn: m,\n      ...e\n    });\n  }, e.windowScroll = m, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"mappings":"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","names":["memo","getDeps","fn","opts","result","deps","depTime","key","debug","Date","now","newDeps","length","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","observer","ResizeObserver","entries","_entries$","_entries$2","width","contentRect","height","scrollElement","getBoundingClientRect","observe","unobserve","observeWindowRect","memoizedCallback","prev","rect","options","horizontal","onResize","innerWidth","innerHeight","addEventListener","capture","passive","removeEventListener","scrollProps","element","window","createOffsetObserver","mode","propX","propY","prevX","prevY","scroll","onScroll","e","target","currentTarget","scrollX","scrollY","observeElementOffset","observeWindowOffset","measureElement","windowScroll","offset","canSmooth","_instance$scrollEleme","scrollTo","behavior","undefined","elementScroll","_instance$scrollEleme2","Virtualizer","constructor","_opts","_this","this","unsubs","measurementsCache","itemMeasurementsCache","pendingMeasuredCacheIndexes","measureElementCache","setOptions","Object","forEach","_ref","value","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","enableSmoothScroll","initialRect","notify","_this$options$onChang","_this$options","call","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","_scrollToOffset","scrollOffset","scrollRect","calculateRange","getSize","getMeasurements","measurements","slice","measuredSize","size","estimateSize","outerSize","_ref2","low","high","getCurrentValue","middle","currentValue","getIndexes","getVirtualItems","indexes","makeMeasureElement","measurableItem","_this$itemMeasurement","item","measuredItemSize","itemSize","destinationOffset","virtualItems","currentMeasureElements","k","len","_this$measureElementC","scrollToOffset","toOffset","_temp","align","smoothScroll","scrollToIndex","_temp2","rest","measurement","getTotalSize","_this$getMeasurements","scrollCheckFrame","clearTimeout","scrollToFn","check","lastOffset","setTimeout","measure","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","useVirtualizerBase","rerender","useReducer","resolvedOptions","useState"],"sources":["../../../virtual-core/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n\n    if (!depsChanged) {\n      return result;\n    }\n\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n\n    if (opts.key && opts.debug != null && opts.debug()) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n\n      const pad = (str, num) => {\n        str = String(str);\n\n        while (str.length < num) {\n          str = ' ' + str;\n        }\n\n        return str;\n      };\n\n      console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n    }\n\n    return result;\n  };\n}\n\n//\nconst defaultKeyExtractor = index => index;\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nconst memoRectCallback = (instance, cb) => {\n  let prev = {\n    height: -1,\n    width: -1\n  };\n  return rect => {\n    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n      cb(rect);\n    }\n\n    prev = rect;\n  };\n};\n\nconst observeElementRect = (instance, cb) => {\n  const observer = new ResizeObserver(entries => {\n    var _entries$, _entries$2;\n\n    cb({\n      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,\n      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height\n    });\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  cb(instance.scrollElement.getBoundingClientRect());\n  observer.observe(instance.scrollElement);\n  return () => {\n    observer.unobserve(instance.scrollElement);\n  };\n};\nconst observeWindowRect = (instance, cb) => {\n  const memoizedCallback = memoRectCallback(instance, cb);\n\n  const onResize = () => memoizedCallback({\n    width: instance.scrollElement.innerWidth,\n    height: instance.scrollElement.innerHeight\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  onResize();\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true\n  });\n  return () => {\n    instance.scrollElement.removeEventListener('resize', onResize);\n  };\n};\nconst scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY']\n};\n\nconst createOffsetObserver = mode => {\n  return (instance, cb) => {\n    if (!instance.scrollElement) {\n      return;\n    }\n\n    const propX = scrollProps[mode][0];\n    const propY = scrollProps[mode][1];\n    let prevX = instance.scrollElement[propX];\n    let prevY = instance.scrollElement[propY];\n\n    const scroll = () => {\n      cb(instance.scrollElement[instance.options.horizontal ? propX : propY]);\n    };\n\n    scroll();\n\n    const onScroll = e => {\n      const target = e.currentTarget;\n      const scrollX = target[propX];\n      const scrollY = target[propY];\n\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll();\n      }\n\n      prevX = scrollX;\n      prevY = scrollY;\n    };\n\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return () => {\n      instance.scrollElement.removeEventListener('scroll', onScroll);\n    };\n  };\n};\n\nconst observeElementOffset = createOffsetObserver('element');\nconst observeWindowOffset = createOffsetObserver('window');\nconst measureElement = (element, instance) => {\n  return element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height'];\n};\nconst windowScroll = (offset, canSmooth, instance) => {\n  var _instance$scrollEleme;\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: offset,\n    behavior: canSmooth ? 'smooth' : undefined\n  });\n};\nconst elementScroll = (offset, canSmooth, instance) => {\n  var _instance$scrollEleme2;\n  (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo == null ? void 0 : _instance$scrollEleme2.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: offset,\n    behavior: canSmooth ? 'smooth' : undefined\n  });\n};\nclass Virtualizer {\n  constructor(_opts) {\n    var _this = this;\n\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.measurementsCache = [];\n    this.itemMeasurementsCache = {};\n    this.pendingMeasuredCacheIndexes = [];\n    this.measureElementCache = {};\n    this.range = {\n      startIndex: 0,\n      endIndex: 0\n    };\n\n    this.setOptions = opts => {\n      Object.entries(opts).forEach(_ref => {\n        let [key, value] = _ref;\n        if (typeof value === 'undefined') delete opts[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        enableSmoothScroll: true,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        ...opts\n      };\n    };\n\n    this.notify = () => {\n      var _this$options$onChang, _this$options;\n\n      (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);\n    };\n\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n\n        this._scrollToOffset(this.scrollOffset, false);\n\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.calculateRange();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, offset => {\n          this.scrollOffset = offset;\n          this.calculateRange();\n        }));\n      }\n    };\n\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? 'width' : 'height'];\n    };\n\n    this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const measuredSize = measurementsCache[key];\n        const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n        const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key\n        };\n      }\n\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {\n      const range = calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset\n      });\n\n      if (range.startIndex !== this.range.startIndex || range.endIndex !== this.range.endIndex) {\n        this.range = range;\n        this.notify();\n      }\n\n      return this.range;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug\n    });\n    this.getIndexes = memo(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({ ...range,\n        overscan,\n        count: count\n      });\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug\n    });\n    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (indexes, measurements, measureElement) => {\n      const makeMeasureElement = index => measurableItem => {\n        var _this$itemMeasurement;\n\n        const item = this.measurementsCache[index];\n\n        if (!measurableItem) {\n          return;\n        }\n\n        const measuredItemSize = measureElement(measurableItem, this);\n        const itemSize = (_this$itemMeasurement = this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;\n\n        if (measuredItemSize !== itemSize) {\n          if (item.start < this.scrollOffset) {\n            if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n              console.info('correction', measuredItemSize - itemSize);\n            }\n\n            if (!this.destinationOffset) {\n              this._scrollToOffset(this.scrollOffset + (measuredItemSize - itemSize), false);\n            }\n          }\n\n          this.pendingMeasuredCacheIndexes.push(index);\n          this.itemMeasurementsCache = { ...this.itemMeasurementsCache,\n            [item.key]: measuredItemSize\n          };\n          this.notify();\n        }\n      };\n\n      const virtualItems = [];\n      const currentMeasureElements = {};\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        var _this$measureElementC;\n\n        const i = indexes[k];\n        const measurement = measurements[i];\n        const item = { ...measurement,\n          measureElement: currentMeasureElements[i] = (_this$measureElementC = this.measureElementCache[i]) != null ? _this$measureElementC : makeMeasureElement(i)\n        };\n        virtualItems.push(item);\n      }\n\n      this.measureElementCache = currentMeasureElements;\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug\n    });\n\n    this.scrollToOffset = function (toOffset, _temp) {\n      let {\n        align = 'start',\n        smoothScroll = _this.options.enableSmoothScroll\n      } = _temp === void 0 ? {} : _temp;\n      const offset = _this.scrollOffset;\n\n      const size = _this.getSize();\n\n      if (align === 'auto') {\n        if (toOffset <= offset) {\n          align = 'start';\n        } else if (toOffset >= offset + size) {\n          align = 'end';\n        } else {\n          align = 'start';\n        }\n      }\n\n      if (align === 'start') {\n        _this._scrollToOffset(toOffset, smoothScroll);\n      } else if (align === 'end') {\n        _this._scrollToOffset(toOffset - size, smoothScroll);\n      } else if (align === 'center') {\n        _this._scrollToOffset(toOffset - size / 2, smoothScroll);\n      }\n    };\n\n    this.scrollToIndex = function (index, _temp2) {\n      let {\n        align = 'auto',\n        smoothScroll = _this.options.enableSmoothScroll,\n        ...rest\n      } = _temp2 === void 0 ? {} : _temp2;\n\n      const measurements = _this.getMeasurements();\n\n      const offset = _this.scrollOffset;\n\n      const size = _this.getSize();\n\n      const {\n        count\n      } = _this.options;\n      const measurement = measurements[Math.max(0, Math.min(index, count - 1))];\n\n      if (!measurement) {\n        return;\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {\n          align = 'end';\n        } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {\n          align = 'start';\n        } else {\n          return;\n        }\n      }\n\n      const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n\n      _this.scrollToOffset(toOffset, {\n        align,\n        smoothScroll,\n        ...rest\n      });\n    };\n\n    this.getTotalSize = () => {\n      var _this$getMeasurements;\n\n      return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;\n    };\n\n    this._scrollToOffset = (offset, canSmooth) => {\n      clearTimeout(this.scrollCheckFrame);\n      this.destinationOffset = offset;\n      this.options.scrollToFn(offset, canSmooth, this);\n      let scrollCheckFrame;\n\n      const check = () => {\n        let lastOffset = this.scrollOffset;\n        this.scrollCheckFrame = scrollCheckFrame = setTimeout(() => {\n          if (this.scrollCheckFrame !== scrollCheckFrame) {\n            return;\n          }\n\n          if (this.scrollOffset === lastOffset) {\n            this.destinationOffset = undefined;\n            return;\n          }\n\n          lastOffset = this.scrollOffset;\n          check();\n        }, 100);\n      };\n\n      check();\n    };\n\n    this.measure = () => {\n      this.itemMeasurementsCache = {};\n      this.notify();\n    };\n\n    this.setOptions(_opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.calculateRange();\n  }\n\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref2) {\n  let {\n    measurements,\n    outerSize,\n    scrollOffset\n  } = _ref2;\n  const count = measurements.length - 1;\n\n  const getOffset = index => measurements[index].start;\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n\n  return {\n    startIndex,\n    endIndex\n  };\n}\n\nexport { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nimport {\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  PartialKeys,\n  Virtualizer,\n  VirtualizerOptions,\n  windowScroll,\n} from '@tanstack/virtual-core'\nexport * from '@tanstack/virtual-core'\n\n//\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<TScrollElement, TItemElement = unknown>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance) => {\n      rerender()\n      options.onChange?.(instance)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<TScrollElement, TItemElement = unknown>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement = unknown>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof window !== 'undefined' ? window : null!),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    ...options,\n  })\n}\n"]},"metadata":{},"sourceType":"script"}