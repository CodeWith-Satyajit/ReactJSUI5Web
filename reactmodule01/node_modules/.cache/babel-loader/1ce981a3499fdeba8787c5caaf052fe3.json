{"ast":null,"code":"import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport { isEscape, isHome, isEnd } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n// Texts\nimport { RANGE_SLIDER_ARIA_DESCRIPTION, RANGE_SLIDER_START_HANDLE_DESCRIPTION, RANGE_SLIDER_END_HANDLE_DESCRIPTION } from \"./generated/i18n/i18n-defaults.js\";\n\n// Styles\nimport rangeSliderStyles from \"./generated/themes/RangeSlider.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n  tag: \"ui5-range-slider\",\n  languageAware: true,\n  managedSlots: true,\n  properties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */{\n    /**\n     * Defines start point of a selection - position of a first handle on the slider.\n     * <br><br>\n     *\n     * @type {sap.ui.webcomponents.base.types.Float}\n     * @defaultvalue 0\n     * @formEvents change input\n     * @formProperty\n     * @public\n     */\n    startValue: {\n      type: Float,\n      defaultValue: 0\n    },\n    /**\n     * Defines end point of a selection - position of a second handle on the slider.\n     * <br><br>\n     *\n     * @type {sap.ui.webcomponents.base.types.Float}\n     * @defaultvalue 100\n     * @formEvents change input\n     * @formProperty\n     * @public\n     */\n    endValue: {\n      type: Float,\n      defaultValue: 100\n    },\n    rangePressed: {\n      type: Boolean\n    }\n  }\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range.</li>\n * <li>max - The maximum value of the slider range.</li>\n * <li>value - The current value of the slider.</li>\n * <li>step - Determines the increments in which the slider will move.</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle.</li>\n * <li>showTickmarks - Displays a visual divider between the step values.</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:</h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>Keyboard Handling</h3>\n *\n * <ul>\n * <li><code>Left or Down Arrow</code> - Moves a component's handle or the entire selection one step to the left;</li>\n * <li><code>Right or Up Arrow</code> - Moves a component's handle or the entire selection one step to the right;</li>\n * <li><code>Left or Down Arrow + Ctrl/Cmd</code> - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Right or Up Arrow + Ctrl/Cmd</code> - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Plus</code> - Same as <code>Right or Up Arrow</code>;</li>\n * <li><code>Minus</code> - Same as <code>Left or Down Arrow</code>;</li>\n * <li><code>Home</code> - Moves the entire selection or the selected handle to the beginning of the component's range;</li>\n * <li><code>End</code> - Moves the entire selection or the selected handle to the end of the component's range;</li>\n * <li><code>Page Up</code> - Same as <code>Right or Up Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Page Down</code> - Same as <code>Left or Down Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Escape</code> - Resets the <code>startValue</code> and <code>endValue</code> properties to the values prior the component focusing;</li>\n * </ul>\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends sap.ui.webcomponents.main.SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n  static get metadata() {\n    return metadata;\n  }\n  static get template() {\n    return RangeSliderTemplate;\n  }\n  static get VALUES() {\n    return {\n      start: \"startValue\",\n      end: \"endValue\"\n    };\n  }\n  static get dependencies() {\n    return [Icon];\n  }\n  static get styles() {\n    return [SliderBase.styles, rangeSliderStyles];\n  }\n  constructor() {\n    super();\n    this._stateStorage.startValue = null;\n    this._stateStorage.endValue = null;\n  }\n  get tooltipStartValue() {\n    const stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.startValue.toFixed(stepPrecision);\n  }\n  get tooltipEndValue() {\n    const stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.endValue.toFixed(stepPrecision);\n  }\n  get _ariaDisabled() {\n    return this.disabled || undefined;\n  }\n  get _ariaLabelledByText() {\n    return RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n  }\n  get _ariaHandlesText() {\n    const isRTL = this.effectiveDir === \"rtl\";\n    const isReversed = this._areValuesReversed();\n    const ariaHandlesText = {};\n    if (isRTL && !isReversed || !isRTL && isReversed) {\n      ariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n      ariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n    } else {\n      ariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n      ariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n    }\n    return ariaHandlesText;\n  }\n\n  /**\n   * Check if the previously saved state is outdated. That would mean\n   * either it is the initial rendering or that a property has been changed\n   * programmatically - because the previous state is always updated in\n   * the interaction handlers.\n   *\n   * Normalize current properties, update the previously stored state.\n   * Update the visual UI representation of the Slider.\n   *\n   */\n  onBeforeRendering() {\n    if (!this.isCurrentStateOutdated()) {\n      return;\n    }\n    this.notResized = true;\n    this.syncUIAndState(\"startValue\", \"endValue\");\n    this._updateHandlesAndRange(null);\n  }\n  _onfocusin(event) {\n    // If this is the initial focusin of the component save its initial\n    // value properties so they could be restored on ESC key press\n    if (!this._getInitialValue(\"endValue\")) {\n      this._setInitialValue(\"startValue\", this.startValue);\n      this._setInitialValue(\"endValue\", this.endValue);\n    }\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n\n  /**\n   * Handles focus out event of the focusable components inner elements.\n   * Prevent focusout when the focus is getting initially set within the slider before the\n   * slider customElement itself is finished focusing.\n   *\n   * Prevents the focus from leaving the Range Slider when the focus is managed between\n   * its inner elements in result of user interactions.\n   *\n   * Resets the stored Range Slider's initial values saved when it was first focused\n   *\n   * @private\n   */\n  _onfocusout(event) {\n    if (this._isFocusing()) {\n      this._preventFocusOut();\n      return;\n    }\n    this._setAffectedValue(null);\n    this._setInitialValue(\"startValue\", null);\n    this._setInitialValue(\"endValue\", null);\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n\n  /**\n  * Handles keyup logic. If one of the handles came across the other\n  * swap the start and end values. Reset the affected value by the finished\n  * user interaction.\n  *\n  * @private\n  */\n  _onkeyup(event) {\n    super._onkeyup(event);\n    this._swapValues();\n    this._setAffectedValue(null);\n  }\n  _handleActionKeyPress(event) {\n    if (isEscape(event)) {\n      this.update(null, this._getInitialValue(\"startValue\"), this._getInitialValue(\"endValue\"));\n      return;\n    }\n\n    // Set the target of the interaction based on the focused inner element\n    this._setAffectedValueByFocusedElement();\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const affectedValue = this._valueAffected;\n\n    // If home/end key is pressed and no single handle is focused the active element\n    // is the range selection - update both start and end values. Otherwise, if 'home'\n    // is pressed the 'startValue'will be used for the start-handle offset calculation,\n    // if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n    if ((isEnd(event) || isHome(event)) && !affectedValue) {\n      this._homeEndForSelectedRange(event, isHome(event) ? \"startValue\" : \"endValue\", min, max);\n      return;\n    }\n\n    // Calculate how much the value should be increased/decreased based on the action key\n    const newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n    if (!newValueOffset) {\n      return;\n    }\n\n    // Update a single value if one of the handles is focused or the range if not already at min or max\n    if (affectedValue && !this._isPressInCurrentRange) {\n      const newValue = this.constructor.clipValue(newValueOffset + this[affectedValue], min, max);\n      this.update(affectedValue, newValue, null);\n    } else if (newValueOffset < 0 && this.startValue > min || newValueOffset > 0 && this.endValue < max) {\n      const newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n      const newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n      this.update(affectedValue, newStartValue, newEndValue);\n    }\n  }\n\n  /**\n   * Determines affected value (start/end) depending on the currently\n   * active inner element within the Range Slider - used in the keyboard handling.\n   *\n   * @private\n   */\n  _setAffectedValueByFocusedElement() {\n    if (this.shadowRoot.activeElement === this._startHandle) {\n      this._setAffectedValue(RangeSlider.VALUES.start);\n    }\n    if (this.shadowRoot.activeElement === this._endHandle) {\n      this._setAffectedValue(RangeSlider.VALUES.end);\n    }\n    if (this.shadowRoot.activeElement === this._progressBar) {\n      this._setAffectedValue(null);\n    }\n    this._setIsPressInCurrentRange(!this._valueAffected);\n  }\n\n  /**\n   * Calculates the start and end values when the 'Home\" or 'End' keys\n   * are pressed on the selected range bar.\n   *\n   * @private\n   */\n  _homeEndForSelectedRange(event, affectedValue, min, max) {\n    const newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n    const newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n    const newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n    this.update(null, newStartValue, newEndValue);\n  }\n\n  /**\n   * Update values, stored inner state and the visual UI representation of the component.\n   * If no specific type of value property is passed - the range is selected - update both handles,\n   * otherwise update the handle corresponding to the affected by the user interacton value prop.\n   *\n   * @private\n   */\n  update(affectedValue, startValue, endValue) {\n    if (!affectedValue) {\n      this.updateValue(\"startValue\", startValue);\n      this.updateValue(\"endValue\", endValue);\n      this._updateHandlesAndRange(null);\n    } else {\n      const newValue = startValue;\n      this._updateHandlesAndRange(newValue);\n      this.updateValue(affectedValue, newValue);\n    }\n  }\n\n  /**\n   * Called when the user starts interacting with the slider\n   *\n   * @private\n   */\n  _onmousedown(event) {\n    // If step is 0 no interaction is available because there is no constant\n    // (equal for all user environments) quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n\n    // Calculate the new value from the press position of the event\n    const newValue = this.handleDownBase(event);\n\n    // Determine the rest of the needed details from the start of the interaction.\n    this._saveInteractionStartData(event, newValue);\n    this.rangePressed = this._isPressInCurrentRange;\n\n    // Do not yet update the RangeSlider if press is in range or over a handle.\n    if (this._isPressInCurrentRange || this._handeIsPressed) {\n      this._handeIsPressed = false;\n      return;\n    }\n\n    // Update Slider UI and internal state\n    this.update(this._valueAffected, newValue, null);\n  }\n\n  /**\n   * Determines and saves needed values from the start of the interaction:\n   *\n   * Is the value calculated is within the currently selected range;\n   * Initial pageX position of the start handle affected by the interaction;\n   * Initial pageX value of the pressed postion;\n   * Affected value property by the action;\n   *\n   * @private\n   */\n  _saveInteractionStartData(event, newValue) {\n    const progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n    // Save the state of the value properties on the start of the interaction\n    this._startValueAtBeginningOfAction = this.startValue;\n    this._endValueAtBeginningOfAction = this.endValue;\n\n    // Save the initial press point coordinates (position)\n    this._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n    // Which element of the Range Slider is pressed and which value property to be modified on further interaction\n    this._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n    // Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n    this._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n  }\n\n  /**\n   * Called when the user moves the slider\n   *\n   * @private\n   */\n  _handleMove(event) {\n    event.preventDefault();\n\n    // If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n\n    // Update UI and state when dragging a single Range Slider handle\n    if (!this._isPressInCurrentRange) {\n      this._updateValueOnHandleDrag(event);\n      return;\n    }\n\n    // Updates UI and state when dragging of the whole selected range\n    this._updateValueOnRangeDrag(event);\n  }\n\n  /**\n   * Updates UI and state when dragging a single Range Slider handle\n   *\n   * @private\n   */\n  _updateValueOnHandleDrag(event) {\n    const newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n    this.update(this._valueAffected, newValue, null);\n  }\n\n  /**\n   * Updates UI and state when dragging of the whole selected range\n   *\n   * @private\n   */\n  _updateValueOnRangeDrag(event) {\n    // Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n    const currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n    const newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n    // No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n    this._setAffectedValue(null);\n\n    // Update the UI and the state acccording to the calculated new values\n    this.update(null, newValues[0], newValues[1]);\n  }\n  _handleUp() {\n    if (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n      this.fireEvent(\"change\");\n    }\n    this._swapValues();\n    this._setAffectedValueByFocusedElement();\n    this._setAffectedValue(null);\n    this._startValueAtBeginningOfAction = null;\n    this._endValueAtBeginningOfAction = null;\n    this._setIsPressInCurrentRange(false);\n    this.handleUpBase();\n    this.rangePressed = false;\n  }\n\n  /**\n   * Determines where the press occured and which values of the Range Slider\n   * handles should be updated on further interaction.\n   *\n   * If the press is not in the selected range or over one of the Range Slider handles\n   * determines which one from the value/endValue properties has to be updated\n   * after the user action (based on closest handle).\n   *\n   * Set flags if the press is over a handle or in the selected range,\n   * in such cases no values are changed on interaction start, but could be\n   * updated later when dragging.\n   *\n   * @private\n   */\n  _pressTargetAndAffectedValue(clientX, value) {\n    const startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n    const endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n    // Check if the press point is in the bounds of any of the Range Slider handles\n    const handleStartDomRect = startHandle.getBoundingClientRect();\n    const handleEndDomRect = endHandle.getBoundingClientRect();\n    const inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n    const inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n    // Remove the flag for value in current range if the press action is over one of the handles\n    if (inHandleEndDom || inHandleStartDom) {\n      this._handeIsPressed = true;\n    }\n\n    // Return that handle that is closer to the press point\n    if (inHandleEndDom || value > this.endValue) {\n      this._setAffectedValue(RangeSlider.VALUES.end);\n    }\n\n    // If one of the handle is pressed return that one\n    if (inHandleStartDom || value < this.startValue) {\n      this._setAffectedValue(RangeSlider.VALUES.start);\n    }\n\n    // Flag if press is in the current select range\n    const isNewValueInCurrentRange = value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n    this._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n  }\n\n  /**\n   * Sets the value property (start/end) that will get updated\n   * by a user action depending on that user action's characteristics\n   * - mouse press position - cursor coordinates relative to the start/end handles\n   * - selected inner element via a keyboard navigation\n   *\n   * @param {string} valuePropAffectedByInteraction The value that will get modified by the interaction\n   * @private\n   */\n  _setAffectedValue(valuePropAffectedByInteraction) {\n    this._valueAffected = valuePropAffectedByInteraction;\n\n    // If the values have been swapped reset the reversed flag\n    if (this._areValuesReversed()) {\n      this._setValuesAreReversed();\n    }\n  }\n\n  /**\n   * Flag if press action is made on the currently selected range of values\n   *\n   * @param {boolean} isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n   * @private\n   */\n  _setIsPressInCurrentRange(isPressInCurrentRange) {\n    this._isPressInCurrentRange = isPressInCurrentRange;\n  }\n\n  /**\n   * Manage the focus between the focusable inner elements within the component.\n   *\n   * On initial focusin or if the whole range is affected by the user interaction\n   * set the focus on the progress selection, otherwise on one of the Range Slider\n   * handles based on the determined affected value by the user action.\n   *\n   * If one of the handles came across the other one in result of a user action\n   * switch the focus between them to keep it visually consistent.\n   *\n   * Note:\n   * In some cases this function is going to get called twice on one user action.\n   *\n   * 1. When the focus is initially set to an inner element it is done in the very beginning,\n   * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n   * is still not being received, causining an immediate focusout that we prevent by\n   * calling this function once again.\n   *\n   * 2. When the focused is manually switched from one inner element to another.\n   * The focusout handler is one and the same for all focusable parts within the\n   * Range Slider and when is called it checks if it should keep the focus within\n   * the component and which part of it should get focused if that is the case.\n   *\n   * @protected\n   */\n  focusInnerElement() {\n    const isReversed = this._areValuesReversed();\n    const affectedValue = this._valueAffected;\n    if (this._isPressInCurrentRange || !affectedValue) {\n      this._progressBar.focus();\n    }\n    if (affectedValue === RangeSlider.VALUES.start && !isReversed || affectedValue === RangeSlider.VALUES.end && isReversed) {\n      this._startHandle.focus();\n    }\n    if (affectedValue === RangeSlider.VALUES.end && !isReversed || affectedValue === RangeSlider.VALUES.start && isReversed) {\n      this._endHandle.focus();\n    }\n  }\n\n  /**\n   * Calculates startValue/endValue properties when the whole range is moved.\n   *\n   * Uses the change of the position of the start handle and adds the initially\n   * selected range to it, to determine the whole range offset.\n   *\n   * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n   * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n   *\n   * @private\n   */\n  _calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n    // Return the current values if there is no difference in the\n    // possitions of the initial press and the current pointer\n    if (this._initialPageXPosition === currentPageXPos) {\n      return [this.startValue, this.endValue];\n    }\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const selectedRange = this.endValue - this.startValue;\n\n    // Computes the new value based on the difference of the current cursor location from the start of the interaction\n    let startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n    // When the end handle reaches the max possible value prevent the start handle from moving\n    // And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n    startValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n    return [startValue, startValue + selectedRange];\n  }\n\n  /**\n   * Computes the new value based on the difference of the current cursor location from the\n   * start of the interaction.\n   *\n   * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n   * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n   *\n   * @private\n   */\n  _calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const step = this._effectiveStep;\n    const dom = this.getBoundingClientRect();\n    let startValue;\n    let startValuePageX;\n    let positionOffset;\n\n    /* Depending on the dragging direction:\n    - calculate the new position of the start handle from its old pageX value combined with the movement offset;\n    - calculate the start value based on its new pageX coordinates;\n    - 'stepify' the calculated value based on the specified step property; */\n    if (currentPageXPos > this._initialPageXPosition) {\n      // Difference between the new position of the pointer and when the press event initial occured\n      positionOffset = currentPageXPos - this._initialPageXPosition;\n      startValuePageX = initialStartHandlePageXPos + positionOffset;\n      startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = this.constructor.getSteppedValue(startValue, step, min);\n    } else {\n      positionOffset = this._initialPageXPosition - currentPageXPos;\n      startValuePageX = initialStartHandlePageXPos - positionOffset;\n      startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = this.constructor.getSteppedValue(startValue, step, min);\n    }\n    return startValue;\n  }\n\n  /**\n   * Updates the visual representation of the component by calculating\n   * the styles of the handles and the range selection based on the new state.\n   *\n   * @private\n   */\n  _updateHandlesAndRange(newValue) {\n    const max = this._effectiveMax;\n    const min = this._effectiveMin;\n    const prevStartValue = this.getStoredPropertyState(\"startValue\");\n    const prevEndValue = this.getStoredPropertyState(\"endValue\");\n    const affectedValue = this._valueAffected;\n\n    // The value according to which we update the UI can be either the startValue\n    // or the endValue property. It is determined in _getClosestHandle()\n    // depending on to which handle is closer the user interaction.\n    if (affectedValue === RangeSlider.VALUES.start) {\n      this._selectedRange = (prevEndValue - newValue) / (max - min);\n      this._firstHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else if (affectedValue === RangeSlider.VALUES.end) {\n      this._selectedRange = (newValue - prevStartValue) / (max - min);\n      this._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else {\n      // When both values are changed - UI sync or moving the whole selected range:\n      this._selectedRange = (this.endValue - this.startValue) / (max - min);\n      this._firstHandlePositionFromStart = (this.startValue - min) / (max - min) * 100;\n      this._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n    }\n  }\n\n  /**\n   * Swaps the start and end values of the handles if one came accros the other:\n   * - If the start value is greater than the endValue swap them and their handles\n   * - If the endValue become less than the start value swap them and their handles\n   *\n   * Switches the focus to the opposite of the currently focused handle.\n   *\n   * Note: Only the property values are reversed, the DOM elements of the handles\n   * corresponding to them are never switched.\n   *\n   * @private\n   */\n  _swapValues() {\n    const affectedValue = this._valueAffected;\n    if (affectedValue === RangeSlider.VALUES.start && this.startValue > this.endValue) {\n      const prevEndValue = this.endValue;\n      this.endValue = this.startValue;\n      this.startValue = prevEndValue;\n      this._setValuesAreReversed();\n      this.focusInnerElement();\n    }\n    if (affectedValue === RangeSlider.VALUES.end && this.endValue < this.startValue) {\n      const prevStartValue = this.startValue;\n      this.startValue = this.endValue;\n      this.endValue = prevStartValue;\n      this._setValuesAreReversed();\n      this.focusInnerElement();\n    }\n  }\n\n  /**\n   * Flag that we have swapped the values of the 'start' and 'end' properties,\n   * to correctly switch the focus within the component from one handle to another\n   * when the swapping is finished. As we only swap property values and not\n   * the handle elements themselves, we must also swap their focus.\n   *\n   * @private\n   */\n  _setValuesAreReversed() {\n    this._reversedValues = !this._reversedValues;\n  }\n  _areValuesReversed() {\n    return this._reversedValues;\n  }\n  get tickmarksObject() {\n    const count = this._tickmarksCount;\n    const arr = [];\n    if (this._hiddenTickmarks) {\n      return [false, false];\n    }\n    for (let i = 0; i <= count; i++) {\n      const isBiggerThanStartValue = this._effectiveMin + i * this.step >= this.startValue;\n      const isBiggerThanEndValue = this._effectiveMin + i * this.step <= this.endValue;\n      arr.push(isBiggerThanStartValue && isBiggerThanEndValue);\n    }\n    return arr;\n  }\n  get _startHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n  }\n  get _endHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n  }\n  get _progressBar() {\n    return this.shadowRoot.querySelector(\".ui5-slider-progress\");\n  }\n  get _ariaLabelledByStartHandleRefs() {\n    return [`${this._id}-accName`, `${this._id}-startHandleDesc`].join(\" \").trim();\n  }\n  get _ariaLabelledByEndHandleRefs() {\n    return [`${this._id}-accName`, `${this._id}-endHandleDesc`].join(\" \").trim();\n  }\n  get _ariaLabelledByProgressBarRefs() {\n    return [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n  }\n  get styles() {\n    return {\n      progress: {\n        \"width\": `${this._selectedRange * 100}%`,\n        \"transform-origin\": `${this.directionStart} top`,\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      startHandle: {\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      endHandle: {\n        [this.directionStart]: `${this._secondHandlePositionFromStart}%`\n      },\n      tickmarks: {\n        \"background\": `${this._tickmarks}`\n      },\n      label: {\n        \"width\": `${this._labelWidth}%`\n      },\n      labelContainer: {\n        \"width\": `100%`,\n        [this.directionStart]: `-${this._labelWidth / 2}%`\n      },\n      tooltip: {\n        \"visibility\": `${this._tooltipVisibility}`\n      }\n    };\n  }\n  static async onDefine() {\n    RangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n  }\n}\nRangeSlider.define();\nexport default RangeSlider;","map":{"version":3,"names":["Float","getI18nBundle","isEscape","isHome","isEnd","SliderBase","Icon","RangeSliderTemplate","RANGE_SLIDER_ARIA_DESCRIPTION","RANGE_SLIDER_START_HANDLE_DESCRIPTION","RANGE_SLIDER_END_HANDLE_DESCRIPTION","rangeSliderStyles","metadata","tag","languageAware","managedSlots","properties","startValue","type","defaultValue","endValue","rangePressed","Boolean","RangeSlider","template","VALUES","start","end","dependencies","styles","constructor","_stateStorage","tooltipStartValue","stepPrecision","_getDecimalPrecisionOfNumber","_effectiveStep","toFixed","tooltipEndValue","_ariaDisabled","disabled","undefined","_ariaLabelledByText","i18nBundle","getText","_ariaHandlesText","isRTL","effectiveDir","isReversed","_areValuesReversed","ariaHandlesText","startHandleText","endHandleText","onBeforeRendering","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandlesAndRange","_onfocusin","event","_getInitialValue","_setInitialValue","showTooltip","_tooltipVisibility","TOOLTIP_VISIBILITY","VISIBLE","_onfocusout","_isFocusing","_preventFocusOut","_setAffectedValue","HIDDEN","_onkeyup","_swapValues","_handleActionKeyPress","update","_setAffectedValueByFocusedElement","min","_effectiveMin","max","_effectiveMax","affectedValue","_valueAffected","_homeEndForSelectedRange","newValueOffset","_handleActionKeyPressBase","_isPressInCurrentRange","newValue","clipValue","newStartValue","newEndValue","shadowRoot","activeElement","_startHandle","_endHandle","_progressBar","_setIsPressInCurrentRange","updateValue","_onmousedown","handleDownBase","_saveInteractionStartData","_handeIsPressed","progressBarDom","querySelector","getBoundingClientRect","_startValueAtBeginningOfAction","_endValueAtBeginningOfAction","_initialPageXPosition","getPageXValueFromEvent","_pressTargetAndAffectedValue","_initialStartHandlePageX","directionStart","left","right","_handleMove","preventDefault","_updateValueOnHandleDrag","_updateValueOnRangeDrag","getValueFromInteraction","currentPageXPos","newValues","_calculateRangeOffset","_handleUp","fireEvent","handleUpBase","clientX","value","startHandle","endHandle","handleStartDomRect","handleEndDomRect","inHandleStartDom","inHandleEndDom","isNewValueInCurrentRange","valuePropAffectedByInteraction","_setValuesAreReversed","isPressInCurrentRange","focusInnerElement","focus","initialStartHandlePageXPos","selectedRange","_calculateStartValueByOffset","step","dom","startValuePageX","positionOffset","computedValueFromPageX","getSteppedValue","prevStartValue","getStoredPropertyState","prevEndValue","_selectedRange","_firstHandlePositionFromStart","_secondHandlePositionFromStart","_reversedValues","tickmarksObject","count","_tickmarksCount","arr","_hiddenTickmarks","i","isBiggerThanStartValue","isBiggerThanEndValue","push","_ariaLabelledByStartHandleRefs","_id","join","trim","_ariaLabelledByEndHandleRefs","_ariaLabelledByProgressBarRefs","progress","tickmarks","_tickmarks","label","_labelWidth","labelContainer","tooltip","onDefine","define"],"sources":["/home/user/projects/reactwithcap01/reactmodule01/node_modules/@ui5/webcomponents/dist/RangeSlider.js"],"sourcesContent":["import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport {\n\tisEscape,\n\tisHome,\n\tisEnd,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n// Texts\nimport {\n\tRANGE_SLIDER_ARIA_DESCRIPTION,\n\tRANGE_SLIDER_START_HANDLE_DESCRIPTION,\n\tRANGE_SLIDER_END_HANDLE_DESCRIPTION,\n} from \"./generated/i18n/i18n-defaults.js\";\n\n// Styles\nimport rangeSliderStyles from \"./generated/themes/RangeSlider.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\tmanagedSlots: true,\n\tproperties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */  {\n\t\t/**\n\t\t * Defines start point of a selection - position of a first handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {sap.ui.webcomponents.base.types.Float}\n\t\t * @defaultvalue 0\n\t\t * @formEvents change input\n\t\t * @formProperty\n\t\t * @public\n\t\t */\n\t\tstartValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines end point of a selection - position of a second handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {sap.ui.webcomponents.base.types.Float}\n\t\t * @defaultvalue 100\n\t\t * @formEvents change input\n\t\t * @formProperty\n\t\t * @public\n\t\t */\n\t\tendValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\n\t\trangePressed: {\n\t\t\ttype: Boolean,\n\t\t},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range.</li>\n * <li>max - The maximum value of the slider range.</li>\n * <li>value - The current value of the slider.</li>\n * <li>step - Determines the increments in which the slider will move.</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle.</li>\n * <li>showTickmarks - Displays a visual divider between the step values.</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:</h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>Keyboard Handling</h3>\n *\n * <ul>\n * <li><code>Left or Down Arrow</code> - Moves a component's handle or the entire selection one step to the left;</li>\n * <li><code>Right or Up Arrow</code> - Moves a component's handle or the entire selection one step to the right;</li>\n * <li><code>Left or Down Arrow + Ctrl/Cmd</code> - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Right or Up Arrow + Ctrl/Cmd</code> - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;</li>\n * <li><code>Plus</code> - Same as <code>Right or Up Arrow</code>;</li>\n * <li><code>Minus</code> - Same as <code>Left or Down Arrow</code>;</li>\n * <li><code>Home</code> - Moves the entire selection or the selected handle to the beginning of the component's range;</li>\n * <li><code>End</code> - Moves the entire selection or the selected handle to the end of the component's range;</li>\n * <li><code>Page Up</code> - Same as <code>Right or Up Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Page Down</code> - Same as <code>Left or Down Arrow + Ctrl/Cmd</code>;</li>\n * <li><code>Escape</code> - Resets the <code>startValue</code> and <code>endValue</code> properties to the values prior the component focusing;</li>\n * </ul>\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends sap.ui.webcomponents.main.SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get template() {\n\t\treturn RangeSliderTemplate;\n\t}\n\n\tstatic get VALUES() {\n\t\treturn {\n\t\t\tstart: \"startValue\",\n\t\t\tend: \"endValue\",\n\t\t};\n\t}\n\n\tstatic get dependencies() {\n\t\treturn [Icon];\n\t}\n\n\tstatic get styles() {\n\t\treturn [SliderBase.styles, rangeSliderStyles];\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = null;\n\t\tthis._stateStorage.endValue = null;\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\tget _ariaDisabled() {\n\t\treturn this.disabled || undefined;\n\t}\n\n\tget _ariaLabelledByText() {\n\t\treturn RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n\t}\n\n\tget _ariaHandlesText() {\n\t\tconst isRTL = this.effectiveDir === \"rtl\";\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst ariaHandlesText = {};\n\n\t\tif ((isRTL && !isReversed) || (!isRTL && isReversed)) {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t} else {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t}\n\n\t\treturn ariaHandlesText;\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programmatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState(\"startValue\", \"endValue\");\n\t\tthis._updateHandlesAndRange(null);\n\t}\n\n\t_onfocusin(event) {\n\t\t// If this is the initial focusin of the component save its initial\n\t\t// value properties so they could be restored on ESC key press\n\t\tif (!this._getInitialValue(\"endValue\")) {\n\t\t\tthis._setInitialValue(\"startValue\", this.startValue);\n\t\t\tthis._setInitialValue(\"endValue\", this.endValue);\n\t\t}\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Handles focus out event of the focusable components inner elements.\n\t * Prevent focusout when the focus is getting initially set within the slider before the\n\t * slider customElement itself is finished focusing.\n\t *\n\t * Prevents the focus from leaving the Range Slider when the focus is managed between\n\t * its inner elements in result of user interactions.\n\t *\n\t * Resets the stored Range Slider's initial values saved when it was first focused\n\t *\n\t * @private\n\t */\n\t_onfocusout(event) {\n\t\tif (this._isFocusing()) {\n\t\t\tthis._preventFocusOut();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAffectedValue(null);\n\t\tthis._setInitialValue(\"startValue\", null);\n\t\tthis._setInitialValue(\"endValue\", null);\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t* Handles keyup logic. If one of the handles came across the other\n\t* swap the start and end values. Reset the affected value by the finished\n\t* user interaction.\n\t*\n\t* @private\n\t*/\n\t_onkeyup(event) {\n\t\tsuper._onkeyup(event);\n\n\t\tthis._swapValues();\n\t\tthis._setAffectedValue(null);\n\t}\n\n\t_handleActionKeyPress(event) {\n\t\tif (isEscape(event)) {\n\t\t\tthis.update(null, this._getInitialValue(\"startValue\"), this._getInitialValue(\"endValue\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// Set the target of the interaction based on the focused inner element\n\t\tthis._setAffectedValueByFocusedElement();\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// If home/end key is pressed and no single handle is focused the active element\n\t\t// is the range selection - update both start and end values. Otherwise, if 'home'\n\t\t// is pressed the 'startValue'will be used for the start-handle offset calculation,\n\t\t// if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\t\tif ((isEnd(event) || isHome(event)) && !affectedValue) {\n\t\t\tthis._homeEndForSelectedRange(event, isHome(event) ? \"startValue\" : \"endValue\", min, max);\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate how much the value should be increased/decreased based on the action key\n\t\tconst newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\n\t\tif (!newValueOffset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update a single value if one of the handles is focused or the range if not already at min or max\n\t\tif (affectedValue && !this._isPressInCurrentRange) {\n\t\t\tconst newValue = this.constructor.clipValue(newValueOffset + this[affectedValue], min, max);\n\t\t\tthis.update(affectedValue, newValue, null);\n\t\t} else if ((newValueOffset < 0 && this.startValue > min) || (newValueOffset > 0 && this.endValue < max)) {\n\t\t\tconst newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n\t\t\tconst newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n\t\t\tthis.update(affectedValue, newStartValue, newEndValue);\n\t\t}\n\t}\n\n\t/**\n\t * Determines affected value (start/end) depending on the currently\n\t * active inner element within the Range Slider - used in the keyboard handling.\n\t *\n\t * @private\n\t */\n\t_setAffectedValueByFocusedElement() {\n\t\tif (this.shadowRoot.activeElement === this._startHandle) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.start);\n\t\t}\n\n\t\tif (this.shadowRoot.activeElement === this._endHandle) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.end);\n\t\t}\n\n\t\tif (this.shadowRoot.activeElement === this._progressBar) {\n\t\t\tthis._setAffectedValue(null);\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(!this._valueAffected);\n\t}\n\n\t/**\n\t * Calculates the start and end values when the 'Home\" or 'End' keys\n\t * are pressed on the selected range bar.\n\t *\n\t * @private\n\t */\n\t_homeEndForSelectedRange(event, affectedValue, min, max) {\n\t\tconst newValueOffset = this._handleActionKeyPressBase(event, affectedValue);\n\t\tconst newStartValue = this.constructor.clipValue(newValueOffset + this.startValue, min, max);\n\t\tconst newEndValue = this.constructor.clipValue(newValueOffset + this.endValue, min, max);\n\n\t\tthis.update(null, newStartValue, newEndValue);\n\t}\n\n\t/**\n\t * Update values, stored inner state and the visual UI representation of the component.\n\t * If no specific type of value property is passed - the range is selected - update both handles,\n\t * otherwise update the handle corresponding to the affected by the user interacton value prop.\n\t *\n\t * @private\n\t */\n\tupdate(affectedValue, startValue, endValue) {\n\t\tif (!affectedValue) {\n\t\t\tthis.updateValue(\"startValue\", startValue);\n\t\t\tthis.updateValue(\"endValue\", endValue);\n\t\t\tthis._updateHandlesAndRange(null);\n\t\t} else {\n\t\t\tconst newValue = startValue;\n\t\t\tthis._updateHandlesAndRange(newValue);\n\t\t\tthis.updateValue(affectedValue, newValue);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t *\n\t * @private\n\t */\n\t_onmousedown(event) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(event);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(event, newValue);\n\n\t\tthis.rangePressed = this._isPressInCurrentRange;\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._isPressInCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis.update(this._valueAffected, newValue, null);\n\t}\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t *\n\t * @private\n\t */\n\t_saveInteractionStartData(event, newValue) {\n\t\tconst progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\t// Save the initial press point coordinates (position)\n\t\tthis._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\t/**\n\t * Called when the user moves the slider\n\t *\n\t * @private\n\t */\n\t_handleMove(event) {\n\t\tevent.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._isPressInCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(event);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(event);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t *\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event) {\n\t\tconst newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\t\tthis.update(this._valueAffected, newValue, null);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t *\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n\t\t// No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\t\tthis._setAffectedValue(null);\n\n\t\t// Update the UI and the state acccording to the calculated new values\n\t\tthis.update(null, newValues[0], newValues[1]);\n\t}\n\n\t_handleUp() {\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._swapValues();\n\t\tthis._setAffectedValueByFocusedElement();\n\t\tthis._setAffectedValue(null);\n\n\t\tthis._startValueAtBeginningOfAction = null;\n\t\tthis._endValueAtBeginningOfAction = null;\n\t\tthis._setIsPressInCurrentRange(false);\n\n\t\tthis.handleUpBase();\n\n\t\tthis.rangePressed = false;\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t *\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX, value) {\n\t\tconst startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t\tconst endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.end);\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._setAffectedValue(RangeSlider.VALUES.start);\n\t\t}\n\n\t\t// Flag if press is in the current select range\n\t\tconst isNewValueInCurrentRange = value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\t\tthis._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n\t}\n\n\t/**\n\t * Sets the value property (start/end) that will get updated\n\t * by a user action depending on that user action's characteristics\n\t * - mouse press position - cursor coordinates relative to the start/end handles\n\t * - selected inner element via a keyboard navigation\n\t *\n\t * @param {string} valuePropAffectedByInteraction The value that will get modified by the interaction\n\t * @private\n\t */\n\t_setAffectedValue(valuePropAffectedByInteraction) {\n\t\tthis._valueAffected = valuePropAffectedByInteraction;\n\n\t\t// If the values have been swapped reset the reversed flag\n\t\tif (this._areValuesReversed()) {\n\t\t\tthis._setValuesAreReversed();\n\t\t}\n\t}\n\n\t/**\n\t * Flag if press action is made on the currently selected range of values\n\t *\n\t * @param {boolean} isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n\t * @private\n\t */\n\t_setIsPressInCurrentRange(isPressInCurrentRange) {\n\t\tthis._isPressInCurrentRange = isPressInCurrentRange;\n\t}\n\n\t/**\n\t * Manage the focus between the focusable inner elements within the component.\n\t *\n\t * On initial focusin or if the whole range is affected by the user interaction\n\t * set the focus on the progress selection, otherwise on one of the Range Slider\n\t * handles based on the determined affected value by the user action.\n\t *\n\t * If one of the handles came across the other one in result of a user action\n\t * switch the focus between them to keep it visually consistent.\n\t *\n\t * Note:\n\t * In some cases this function is going to get called twice on one user action.\n\t *\n\t * 1. When the focus is initially set to an inner element it is done in the very beginning,\n\t * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n\t * is still not being received, causining an immediate focusout that we prevent by\n\t * calling this function once again.\n\t *\n\t * 2. When the focused is manually switched from one inner element to another.\n\t * The focusout handler is one and the same for all focusable parts within the\n\t * Range Slider and when is called it checks if it should keep the focus within\n\t * the component and which part of it should get focused if that is the case.\n\t *\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (this._isPressInCurrentRange || !affectedValue) {\n\t\t\tthis._progressBar.focus();\n\t\t}\n\n\t\tif ((affectedValue === RangeSlider.VALUES.start && !isReversed) || (affectedValue === RangeSlider.VALUES.end && isReversed)) {\n\t\t\tthis._startHandle.focus();\n\t\t}\n\n\t\tif ((affectedValue === RangeSlider.VALUES.end && !isReversed) || (affectedValue === RangeSlider.VALUES.start && isReversed)) {\n\t\t\tthis._endHandle.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\t// Return the current values if there is no difference in the\n\t\t// possitions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tstartValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tif (currentPageXPos > this._initialPageXPosition) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t/**\n\t * Updates the visual representation of the component by calculating\n\t * the styles of the handles and the range selection based on the new state.\n\t *\n\t * @private\n\t */\n\t_updateHandlesAndRange(newValue) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\");\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\");\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (affectedValue === RangeSlider.VALUES.start) {\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (affectedValue === RangeSlider.VALUES.end) {\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = ((this.endValue - min) / (max - min)) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps the start and end values of the handles if one came accros the other:\n\t * - If the start value is greater than the endValue swap them and their handles\n\t * - If the endValue become less than the start value swap them and their handles\n\t *\n\t * Switches the focus to the opposite of the currently focused handle.\n\t *\n\t * Note: Only the property values are reversed, the DOM elements of the handles\n\t * corresponding to them are never switched.\n\t *\n\t * @private\n\t */\n\t_swapValues() {\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (affectedValue === RangeSlider.VALUES.start && this.startValue > this.endValue) {\n\t\t\tconst prevEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = prevEndValue;\n\n\t\t\tthis._setValuesAreReversed();\n\t\t\tthis.focusInnerElement();\n\t\t}\n\n\t\tif (affectedValue === RangeSlider.VALUES.end && this.endValue < this.startValue) {\n\t\t\tconst prevStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = prevStartValue;\n\n\t\t\tthis._setValuesAreReversed();\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Flag that we have swapped the values of the 'start' and 'end' properties,\n\t * to correctly switch the focus within the component from one handle to another\n\t * when the swapping is finished. As we only swap property values and not\n\t * the handle elements themselves, we must also swap their focus.\n\t *\n\t * @private\n\t */\n\t_setValuesAreReversed() {\n\t\tthis._reversedValues = !this._reversedValues;\n\t }\n\n\t _areValuesReversed() {\n\t\treturn this._reversedValues;\n\t}\n\n\tget tickmarksObject() {\n\t\tconst count = this._tickmarksCount;\n\t\tconst arr = [];\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn [false, false];\n\t\t}\n\n\t\tfor (let i = 0; i <= count; i++) {\n\t\t\tconst isBiggerThanStartValue = this._effectiveMin + (i * this.step) >= this.startValue;\n\t\t\tconst isBiggerThanEndValue = this._effectiveMin + (i * this.step) <= this.endValue;\n\n\t\t\tarr.push(isBiggerThanStartValue && isBiggerThanEndValue);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tget _startHandle() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t}\n\n\tget _endHandle() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\t}\n\n\tget _progressBar() {\n\t\treturn this.shadowRoot.querySelector(\".ui5-slider-progress\");\n\t}\n\n\tget _ariaLabelledByStartHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-startHandleDesc`].join(\" \").trim();\n\t}\n\n\tget _ariaLabelledByEndHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-endHandleDesc`].join(\" \").trim();\n\t}\n\n\tget _ariaLabelledByProgressBarRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"width\": `${this._selectedRange * 100}%`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\ttickmarks: {\n\t\t\t\t\"background\": `${this._tickmarks}`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tRangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,6CAA6C;AAC/D,SAASC,aAAa,QAAQ,4CAA4C;AAC1E,SACCC,QAAQ,EACRC,MAAM,EACNC,KAAK,QACC,sCAAsC;AAC7C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,IAAI,MAAM,WAAW;AAC5B,OAAOC,mBAAmB,MAAM,kDAAkD;;AAElF;AACA,SACCC,6BAA6B,EAC7BC,qCAAqC,EACrCC,mCAAmC,QAC7B,mCAAmC;;AAE1C;AACA,OAAOC,iBAAiB,MAAM,uCAAuC;;AAErE;AACA;AACA;AACA,MAAMC,QAAQ,GAAG;EAChBC,GAAG,EAAE,kBAAkB;EACvBC,aAAa,EAAE,IAAI;EACnBC,YAAY,EAAE,IAAI;EAClBC,UAAU,EAAE,6DAA+D;IAC1E;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,UAAU,EAAE;MACXC,IAAI,EAAElB,KAAK;MACXmB,YAAY,EAAE;IACf,CAAC;IACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,QAAQ,EAAE;MACTF,IAAI,EAAElB,KAAK;MACXmB,YAAY,EAAE;IACf,CAAC;IAEDE,YAAY,EAAE;MACbH,IAAI,EAAEI;IACP;EACD;AACD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,SAASlB,UAAU,CAAC;EACpC,WAAWO,QAAQ,GAAG;IACrB,OAAOA,QAAQ;EAChB;EAEA,WAAWY,QAAQ,GAAG;IACrB,OAAOjB,mBAAmB;EAC3B;EAEA,WAAWkB,MAAM,GAAG;IACnB,OAAO;MACNC,KAAK,EAAE,YAAY;MACnBC,GAAG,EAAE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"},"metadata":{},"sourceType":"module"}